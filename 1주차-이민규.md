# 1주차 - 이민규

## 추상화(Abstraction) vs 캡슐화(Encapsulation) vs 정보 은닉(Information hiding)

### 추상화

- **추상화의 본질은 본질적이지 않은 디테일을 생략하면서 본질적인 성질만을 추출하는 것**
- 추상화는 과정(process)와 실체(entity) 두 가지 의미로 모두 사용된다.
    - process로써의 추상화 : 본질적인 세부사항을 무시한 채, 항목의 필수적인 세부사항의 추출을 의미
    - entity로써의 추상화 : 실제 아이템의 focused representation
- **추상화는 정보 숨기기 측면에서 정의되지 않는다.** 즉 추상화는 어떤 정보가 다른 정보보다 더 중요하다는 것을 명시한다고 말할 수도 있겠지만, 중요하지 않는 정보를 취급하기 위한 특정 메커니즘을 명시하지 않는다.

### 정보 은닉

- **본질적 특성에 기여하지 않는 물체의 모든 세부사항을 숨기는 과정**
- **소프트웨어 컴포넌트의 사용자(클래스 등)가 컴포넌트의 (초기화·접근 방법등의) 본질적인 세부사항만 알면 되고 구현의 세부사항을 알 필요가 없다는 원칙**
- **추상화는 어떤 정보를 숨겨야 하는지를 식별하는 기법으로 사용될 수 있다**

    예를 들어, Functional Abstraction에서 목록에 항목을 추가할 수 있는 기능이 중요하다고 말할 수 있지만, 그것이 어떻게 이루어지는지에 대한 세부사항은 관심사가 아니며 숨겨져야 한다. 

    data Abstraction에서, 리스트는 정보를 저장할 수 있는 장소라고 얘기할 수 있지만, 
    리스트가 실제로 어떻게 구현되는지는 중요하지 않고, 숨겨져야 한다.

- **정보의 숨김(Information hiding)과 어떤 정보를 숨길지 식별하는 데 도움이 되는 기술(Abstraction)을 구별하지 못할 때 혼란이 발생할 수 있다.**

### 캡슐화

- 추상화와 마찬가지로 과정(process)와 실체(entity) 두 가지 의미로 모두 사용된다.
    - 하나의 과정으로써 캡슐화는 하나 이상의 항목을 (물리적 또는 논리적) 컨테이너 안에 감싸는 행위를 의미한다.
    - 하나의 실체로써 캡슐화는 하나 이상의 품목을 보유하는 패키지나 인클로저를 말한다.
- **캡슐화가 '정보 은닉'과 같은 것이었다면, '캡슐화 한 모든 것을 숨겼다'는 이야기이며
이것은 명백히 사실이 아니다.** 예를 들어, 정보가 배열 내에 캡슐화될 수 있더라도, 
이 정보는 대개 숨겨지지 않는다.(다른 메커니즘을 통해 숨겨지지 않는 한)
- **클래스와 같은 캡슐화 메커니즘이 일부 정보를 숨길 수 있게 한다는 것은 사실이다. 
그러나 또한 일부 정보를 가시적으로 볼 수 있게 한다. (private, public)**

## 결론

**추상화, 정보 숨기기, 캡슐화는 매우 다르지만 매우 관련성이 높은 개념이다. 
추상화는 어떤 특정한 정보가 보여야 하고 어떤 정보가 숨겨져야 하는지를 식별하는 데 도움을 주는 기술이라고 얘기할 수 있다. 캡슐화는 그 다음에 숨겨야 할 것을 숨기고, 보이도록 의도된 것을 가시화시키는 방법으로 정보를 포장하는 기술이다.**

> reference : [https://web.archive.org/web/20071214085409/http://www.itmweb.com/essay550.htm](https://web.archive.org/web/20071214085409/http://www.itmweb.com/essay550.htm)

## Overriding & Overloading

일반적으로 사용하는 알기 쉬운 기준은 **메소드의 시그니처가 동일하다면 Overriding(재정의)**

**동일하지 않다면 Overloading**

다음 코드의 실행결과는 무엇일까?? 이것은 Overriding일까??

```java
class Super {
    static void print() {
        System.out.println("Super 클래스의 static method가 실행되었습니다.");
    }
}

class Sub extends Super {
    static void print() {
        System.out.println("Sub 클래스의 static method가 실행되었습니다.");
    }
    void a(){
        System.out.println("hi");
    }
    static void b(){
	System.out.println("bye");
    }
}

// main
Super obj = new Sub();
Sub.print();
obj.print() // bad coding style;
obj.a(); // compile error
obj.b(); // compile error
((Sub)obj).a(); // 컴파일 가능
((Sub)obj).b(); // 컴파일 가능
```

`obj.print() : Super 클래스의 static method가 실행되었습니다.`

`Sub.print() : Sub 클래스의 static method가 실행되었습니다.`

**Overriding은 클래스의 인스턴스에 의존하는 개념. 슈퍼클래스로 선언된 서브클래스 객체가 실행하는 메소드를 compile-time에 정하는 것이 아니라 run-time 시에 재정의되어 있는지 확인 후 결정하는 것(동적바인딩, 다이나믹디스패칭). 하지만 static method는 compile-time에 실행할 메소드가 결정되므로 overriding 개념을 적용할 수 없다. `Sub.print()` 는 단순히 단순히 Super 클래스의 메소드를 숨기고(hiding) Sub 클래스의 static method를 실행하게끔 하는 것이지 overriding이라 하지 않는다.** 

> reference : [https://stackoverflow.com/questions/2223386/why-doesnt-java-allow-overriding-of-static-methods](https://stackoverflow.com/questions/2223386/why-doesnt-java-allow-overriding-of-static-methods)

## LinkedList vs ArrayList

[LinkedList와 ArrayList 비교표 ](1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20dc9b697a35fc4f0f84d368b3e7ce4044/LinkedList%E1%84%8B%E1%85%AA%20ArrayList%20%E1%84%87%E1%85%B5%E1%84%80%E1%85%AD%E1%84%91%E1%85%AD%20a5407db331b349ea8871be6febe66f0d.csv)

### LinkedList를 사용할 때 장단점

- **Iterator를 재사용하면서** list 중간에 insert 또는 remove를 수행 → 매 수행시마다 O(1)

    반면 ArrayList로 같은 동작을 수행시 element-shift로 인해 O(N)

- **원소를 참조하는데 걸리는 시간복잡도 O(N)** → LinkedList를 안쓰게 하는 가장 큰 단점

### ArrayList를 사용할 때 장단점

- **원소를 참조하거나 삽입(마지막에)하는데 걸리는 시간복잡도 O(1)**

    → ArrayList를 사용하게 하는 가장 큰 장점

- Iterator를 재사용하면서 list 중간에 logic을 수행시 → 매 수행시마다 O(N)

    → 단점이긴 하지만 문제되는 일이 흔치 않음

### 성능 비교 Code

```java
import java.util.*;

public class ListPerformanceCompare {
    public static void main(String[] args) {
        List<Integer> list1 = new LinkedList<>();
        List<Integer> list2 = new ArrayList<>();

        long startTime;
        long endTime;

        int numOfData = 1000000;
        int result;

        startTime = System.currentTimeMillis();
        for(int i=0; i<numOfData; i++) {
            list1.add(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList 데이터 " + numOfData + "개를 순차적으로 삽입시 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        for(int i=0; i<numOfData; i++) {
            list1.add(0, i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList 데이터 " + numOfData + "개를 앞으로 삽입시 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        result = list1.get(numOfData/2);
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList 중간 데이터 참조에 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        result = list1.get(0);
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList 양 끝 데이터 참조에 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        Iterator<Integer> iter = list1.iterator();
        while(iter.hasNext()) {
            int val = iter.next();
            if(val % 2 == 0) iter.remove();
        }
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList를 iterator로 순회하며 2의 배수를 삭제하는데 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        list1.removeIf(e -> e % 2 == 0);
        endTime = System.currentTimeMillis();
        System.out.println("LinkedList를 removeIf 메소드를 사용해 2의 배수를 삭제하는데 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        for(int i=0; i<numOfData; i++) {
            list2.add(i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList 데이터 " + numOfData + "개를 순차적으로 삽입시 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        for(int i=0; i<numOfData; i++) {
            list2.add(0, i);
        }
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList 데이터 " + numOfData + "개를 앞으로 삽입시 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        result = list2.get(numOfData/2);
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList 중간 데이터 참조에 걸린 시간 : " +
                (endTime - startTime)/1000.0);

        startTime = System.currentTimeMillis();
        result = list1.get(0);
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList 양 끝 데이터 참조에 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        iter = list2.iterator();
        while(iter.hasNext()) {
            int val = iter.next();
            if(val % 2 == 0) iter.remove();
        }
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList를 iterator로 순회하며 2의 배수를 삭제하는데 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");

        startTime = System.currentTimeMillis();
        list2.removeIf(e -> e % 2 == 0);
        endTime = System.currentTimeMillis();
        System.out.println("ArrayList를 removeIf 메소드를 사용해 2의 배수를 삭제하는데 걸린 시간 : " +
                (endTime - startTime)/1000.0 + "sec");
    }
}
```

중복을 제거해서 함수를 인자로 넘겨서 메소드 형태로 짤 수 없을까?? 질문 AOP, Proxy 패턴

![1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20dc9b697a35fc4f0f84d368b3e7ce4044/result.png](1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20-%20%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20dc9b697a35fc4f0f84d368b3e7ce4044/result.png)

> reference : [https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist-in-java](https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist-in-java)

## Final keyword

- **final 변수**
    - 원시 타입 : 한번 초기화 된 변수는 값을 변경할 수 없는 상수값이 됨
    - 참조 타입 : 한번 객체를 참조한 참조변수는 다른 객체를 참조할 수 없음
                **단 참조 객체가 immutable 하다는 이야기가 아님**

- **final 클래스** : final로 선언된 클래스는 다른 클래스가 상속할 수 없음
- **final 메소드** : final로 선언된 메소드는 다른 메서드로 오버라이딩할 수 없음

## Object 클래스의 메소드

- Object에서 final이 아닌 메서드(equals, hashCode, toString, clone, finalize)는 **모두 overriding을**

    **염두해 두고 설계된 것**이라 재정의 시 지켜야 하는 규약이 명확히 정의되어 있음

- 만일 메소드를 잘못 재정의 하면 이 규약을 준수한다고 가정하는 클래스(HashMap, HashSet 등)

    는 오작동하게 됨.

### equals : 논리적 동치성을 검사하는 메서드

- **제 1원칙 : equals를 재정의 할 필요가 없는 경우에는 재정의하지 말 것**
    - 각 인스턴스가 본질적으로 고유하다 ex) Thread
    - 인스턴스의 논리적 동치성을 검사할 일이 없다.
    - 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 맞는다.
    - 클래스가 private이라 equals 메서드를 호출할 일이 없다.

**equals 메서드를 재정의 해야 하는 경우**

객체 식별성(Object identity : 두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야

하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의되지 않았을 때

주로 Integer, String 같은 값을 표현하는 클래스들이 여기에 해당하는데 이런 클래스의 비교에서

**물리적 동치성이란 두 참조변수가 같은 객체를 가리키고 있는지를 의미하고 논리적 동치성이란** 

**두 참조 객체가 같은 값을 가지고 있는지를 의미한다. 따라서 Wrapper class와 String class 에서는** 

**equals가 논리적 동치성을 검사하도록 이미 재정의 되어 있다.**

### equals 메서드의 재정의 규약

- 반사성(reflexity) : null이 아닌 모든 참조 값 x에 대해 `x.equals(x)`는 `true`이다.
- 대칭성(symmetry) : null이 아닌 모든 참조 값 x, y에 대해 `x.equals(y)`가 `true`이면

    `y.equals(x)`도 `true`이다.

- 추이성(transitivity) : null이 아닌 모든 참조 값 x, y, z에 대해 `x.equals(y)`와 `y.equals(z)`가

    `true`이면 `x.equals(z)`도 `true`이다.

- 일관성(consistency) : null이 아닌 참조 값 x, y에 대해 `x.equals(y)`는 항상 같은 값을 반환한다.
- null-아님 : null이 아닌 모든 참조 값 x에 대해 `x.equals(null)`은 `false`이다.

**Tip : 논리적 동치성을 부여하는 그룹끼리 묶어 disjoint set를 구성할 수 있다면 재정의 규약을 만족**

잘못된 equals 메서드의 재정의의 예

```java
public final class CaseInsensitiveString() {
    private final String s;

    public CaseInsensitiveString(String s) {
        this.s = Objects.requireNonNull(s, "String must not be null");
    }
	
    @Override
    public boolean equals(Object o) {
        if(o instanceof CaseInsensitiveString) {
	    return s.equalsIgnoreCase((CaseInsensitiveString) o).s);
	// 없애야 하는 불필요한 부분
	if(o instanceof String) {
	    return s.equalsIgnoreCase((String) o)
	}
	return false;
    }
} 
```

**equals 재정의 규약을 어긴다면 그 객체를 사용하는 다른 객체들이 어떻게 반응하는지 알 수 없다.**

```java
CaseInsensitiveString obj1 = new CaseInsensitiveString("Polish");
String s = "polish";
List<CaseInsensitiveString> list = new ArrayList<>();
list.add(obj1);
System.out.println(list.contains(s));
```

잘못된 equals 메서드 재정의의 예2

```java
class Point {
    int x;
    int y;
    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj) {
        if(obj instanceof Point) {
            Point p = (Point) obj;
            return p.x == x && p.y == y;
        }
        return false;
    }
}

class ColorPoint extends Point {
    String color;
    ColorPoint(int x, int y, String color) {
        super(x, y);
        this.color = color;
    }

    @Override
    public boolean equals(Object obj) {
        if(!(obj instanceof ColorPoint)) return false;
        return super.equals(obj) && ((ColorPoint) obj).color.equals(color);
    }
}
```

다음과 같이 수정한다면 어떨까??

```java
class ColorPoint extends Point {
    String color;
    ColorPoint(int x, int y, String color) {
        super(x, y);
        this.color = color;
    }

    @Override
    public boolean equals(Object obj) {
        // Point 클래스외 관계 없는 객체와의 비교
        if(!(obj instanceof Point)) return false;
        // Point 클래스 객체와의 비교
        if(!(obj instanceof ColorPoint)) return obj.equals(this);
        // ColorPoint 클래스 객체와의 비교
        return super.equals(obj) && ((ColorPoint) obj).color.equals(color);
    }
}
```

해결책1) getClass()를 사용하여 같은 구현 클래스의 객체와 비교할 때만 true를 반환하도록 한다.

- 이는 equals 재정의 규약은 지키지만 리스코프 치환 원칙을 위배한다.
    - **리스코프 치환 원칙(Liskov Substitution Principle)**

        어떤 타입에 있어 중요한 속성이라면 그 하위 타입에서도 마찬가지로 중요하다.

        따라서 그 타입의 모든 메서드가 하위 타입에서도 똑같이 잘 작동해야한다.

- 이는 앞서의 **"Point의 하위 클래스는 정의상 여전히 Point이므로 어디서든 Point로써 활용될 수 있어야 한다"**를 표현한 말이다.

**구체 클래스를 확장해 새로운 필드를 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.**

해결책2) 같은 구현 클래스의 객체와 비교할 때만 true을 반환하 되, Point를 상속이 아닌 컴포지션을

활용하여 Point 클래스의 객체로써 활용할 수 있게 한다.

```java
class ColorPoint {
    private final Point point;
    private final String color;
    ColorPoint(int x, int y, String color) {
        point = new Point(x, y);
        this.color = color;
    }

    public Point asPoint() {
        return point;
    }

    @Override
    public boolean equals(Object obj) {
        if(!(obj instanceof ColorPoint)) return false;
        ColorPoint cp = (ColorPoint) obj;
        return cp.point.equals(point) && cp.color.equals(color);
    }
}
```

### **hashCode : 객체의 해쉬값을 반환하는 메서드**

equals를 재정의한 클래스 모두에서 hasCode도 재정의해야 한다. 그렇지 않드면 hashCode 규약을

어기게 되어 해당 클래스의 객체를 HashMap이나 HashSet 같은 Collection의 element로 사용할 때

문제를 일으킨다.

### hashCode() 메서드 규약

- equals 비교에 사용되는 정보가 변경되지 않았다면, 애플리케이션이 실행되는 동안 그 객체의

    hashCode 메서드는 몇 번을 호출해도 일관되게 항상 같은 값을 반환해야 한다.

- **equals(Object)가 true라면, 두 객체의 hashCode는 똑같은 값을 반환해야 한다.**
- equals(Object)가 false라도, 두 객체의 hashCode는 같을 수 있다. 하지만 다른 객체에 대해서는

    다른 값을 반환해야 해시테이블의 성능이 좋아진다.

**hashCode 재정의를 잘못했을 때 문제가 되는 조항은 두 번째이다. 즉 논리적으로 같은 객체는 같은**

**해시코드를 반환해야 한다.**

**HashSet이나 HashMap에서 논리적으로 같은 객체임을 판단하는 과정**

1. 두 객체의 hashCode를 비교 → 해시코드가 다르면 2번 조항에 의해 두 객체는 다른 객체이다.
2. 두 객체의 equals 비교 → 논리적으로 동일한 객체는 equals 값이 항상 true이다.

hashCode를 재정의 하지 않았을 때 생기는 문제의 예

```java
import java.io.*;
import java.util.*;

class Point {
    int x;
    int y;
    Point(int x, int y) {
        this.x = x;
        this.y = y;
    }

    @Override
    public boolean equals(Object obj) {
        if(obj instanceof Point) {
            Point p = (Point) obj;
            return p.x == x && p.y == y;
        }
        return false;
    }
}

public class Main {
    public static void main(String[] args) {
        HashSet<Point> pointHashSet = new HashSet<>();
        pointHashSet.add(new Point(1, 1));
        pointHashSet.add(new Point(1, 1));
        System.out.println(pointHashSet.size());
    }
}
```

> reference : Effective Java 3/E Chapter3
