# 김지훈

## 1. JVM

![%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%B5%E1%84%92%E1%85%AE%E1%86%AB%20fd651860ca8046d3b0b4f08c4b14a000/Untitled.png](%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%B5%E1%84%92%E1%85%AE%E1%86%AB%20fd651860ca8046d3b0b4f08c4b14a000/Untitled.png)

![%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%B5%E1%84%92%E1%85%AE%E1%86%AB%20fd651860ca8046d3b0b4f08c4b14a000/Untitled%201.png](%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%B5%E1%84%92%E1%85%AE%E1%86%AB%20fd651860ca8046d3b0b4f08c4b14a000/Untitled%201.png)

([https://dzone.com/articles/jvm-architecture-explained](https://dzone.com/articles/jvm-architecture-explained))

### 1.0. 개념

- Java의 바이트 코드(.class 파일)를 OS에 특화된 코드로 변환(interpreter와 JIT Compiler)하여 실행한다.
- 메모리 관리, GC를 수행한다.
- Java와 OS사이의 중개자 역할로, Java가 OS로부터 독립적 실행이 가능하도록 해준다. (Write Once Run Anywhere)

### 1.1. 클래스 로더

- 컴파일 결과로 만들어진 .class 파일(바이트 코드)을 읽어들여 메모리에 배치
- 크게 로딩, 링킹, 초기화 순으로 진행된다.
- 로딩(loading) : 클래스 읽어오는 과정
    - ~~클래스 로더가 .class 파일을 읽고 그 내용에 따라 적절한 바이너리 데이터를 만들고 "메소드" 영역에 저장~~
    - ~~부트스트랩 클래스 로더, 익스텐션 클래스 로더, 애플리케이션 클래스 로더~~
- 링킹(linking) : 레퍼런스를 연결하는 과정
    - ~~Verify : .class 파일 형식이 유효한지 체크한다.~~
    - ~~Prepare : 클래스 변수(static 변수)와 기본값에 필요한 메모리~~
    - ~~Resolve : 심볼릭 메모리 레퍼런스를 메소드 영역에 있는 실제 레퍼런스로 교체~~
- 초기화(initailization) : static 값들 초기화 및 변수에 할당

### 1.2. 메모리(Runtime Data Areas)

![%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%B5%E1%84%92%E1%85%AE%E1%86%AB%20fd651860ca8046d3b0b4f08c4b14a000/Untitled%202.png](%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%B5%E1%84%92%E1%85%AE%E1%86%AB%20fd651860ca8046d3b0b4f08c4b14a000/Untitled%202.png)

([https://hongsii.github.io/2018/12/20/jvm-memory-structure/](https://hongsii.github.io/2018/12/20/jvm-memory-structure/))

- 메소드 : 클래스 수준의 정보(클래스 이름, 부모 클래스 이름, 메소드, 변수 등) 저장(공유 자원)
- 힙 : 객체 저장(공유 자원)
- 스택 : 쓰레드마다 런타임 스택을 만들고, 그 안에 메소드 호출을 스택 프레임이라 부르는 블록으로 쌓는다. 쓰레드가 종료되면 런타임 스택도 사라진다.
- [PC(Program Counter) 레지스터](https://javapapers.com/core-java/java-jvm-run-time-data-areas/#Program_Counter_PC%20Register) : 쓰레드마다 쓰레드 내 현재 실행할 스택 프레임을 가리키는 포인터가 생성된다.
- 네이티브 메소드 스택
    - 자바 이외의 언어(C, C++, 어셈블리 등)로 작성된 코드를 실행할 때, 할당되는 영역

### 1.3. 실행 엔진(Execution Engine)

- 인터프리터 : 바이트 코드를 한 줄씩 실행
- JIT 컴파일러 : 인터프리터 효율을 높이기 위해 인터프리터가 반복되는 코드를 발견하면 JIT 컴파일러가 반복되는 코드를 모두 네이티브 코드로 바꿔둔다. 그 다음부터 인터프리터는 네이티브 코드로 컴파일된 코드를 바로 사용한다.
- GC(Garbage Collector) : 더 이상 참조되지 않는 객체를 모아서 정리한다.
    - STW(Stop-The-World) : GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것

### 1.4. JNI(Java Native Interface)

- 자바 애플리케이션에서 네이티브 응용 프로그램(하드웨어와 운영 체제 플랫폼에 종속된 프로그램들)과 C, C++, 어셈블리 등으로 작성된 함수를 사용할수 있는 방법을 제공
- Native 키워드를 사용한 메소드 호출
- [예제](https://schlining.medium.com/a-simple-java-native-interface-jni-example-in-java-and-scala-68fdafe76f5f)

### 1.5.  네이티브 메소드 라이브러리

- C, C++로 작성된 라이브러리

---

## 2. GC

### 2.1 개념

- Java에서는 **개발자가** 프로그램 코드로 **메모리를 명시적으로 해제하지 않기 때문에** 가비지 컬렉터(Garbage Collector)가 더 이상 필요 없는 (쓰레기) 객체를 찾아 지우는 작업 수행

### 2.2 GC의 두 가지 전제 조건

- 대부분의 객체는 금방 접근 불가능 상태(unreachable)가 된다.
- 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.

### 2.3 영역 구분

- Young 영역
    - 자바 객체의 대부분이 생성될 때 저장되는 공간(너무 커서 이 영역에 들어갈 수 없는 객체는 더 윗 세대(?)로 들어간다)
    - 시간이 지나 우선순위가 낮아지면 `Old` 영역으로 옮겨진다. 이 영역에서 객체가 사라질 때 `Minor GC`가 발생
    - 세부 영역
        - Eden 영역
        - Survivor 영역(2개)
- Old 영역
    - Young 영역에서 저장되었던 객체 중에 오래된 객체가 이동되어 저장되는 영역
    - 이 영역에서 객체가 사라질 때 `Major GC(Full GC)`가 발생

### 2.4  Minor GC 방식

- 세부 과정
    - 새로 생성한 대부분의 객체는 Eden 영역에 위치
    - Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다.
    - Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.
    - 하나의 Survivor 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역으로 이동한다. 그리고 가득 찬 Survivor 영역은 아무 데이터도 없는 상태로 된다.
    - 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 Old 영역으로 이동하게 된다.
- Survivor 영역 중 하나는 반드시 비어 있는 상태로 남아 있어야 한다.
    - 두 Survivor 영역에 모두 데이터가 존재하거나, 두 영역 모두 사용량이 0이라면 여러분의 시스템은 정상적인 상황이 아니라고 생각하면 된다.

### 2.5 Major GC 방식

- Serial GC
    - Young 영역에서의 GC는 위의 Minor GC 방식 사용
    - Old 영역에서의 GC는 mark-sweep-compact 방식 사용
        - mark : Old 영역에 살아 있는 객체를 식별
        - sweep : 힙(heap)의 앞 부분부터 확인하여 살아 있는 것만 남긴다
        - compaction(조각 모음) : 각 객체들이 연속되게 쌓이도록 힙의 가장 앞 부분부터 채워서 객체가 존재하는 부분과 객체가 없는 부분으로 나눈다. (Stop-the-world)

- Parallel GC
    - Parallel GC는 Serial GC와 기본적인 알고리즘은 같지만 Parallel GC와는 다르게 GC를 처리하는 쓰레드가 여러 개인 방식
    - Throughput GC라고도 불린다.

- Parallel Old GC
    - Young 영역에서의 GC는 Parallel GC의 방식과 동일
    - Old 영역에서의 GC는 Mark-Summary-Compaction 방식
        - Summary :  GC를 수행한 영역에 대해서 별도로 살아 있는 객체를 식별한다는 점에서 Mark-Sweep-Compaction 알고리즘의 Sweep 단계와 다르며, 약간 더 복잡한 단계를 거친다

- CMS GC

- G1 GC
    - 전체 heap을 체스판처럼 여러 영역(Region)으로 나누고 Region에 역할(Eden, Survivor, Old)이 동적으로 부여되는 상태

        ![%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%B5%E1%84%92%E1%85%AE%E1%86%AB%20fd651860ca8046d3b0b4f08c4b14a000/Untitled%203.png](%E1%84%80%E1%85%B5%E1%86%B7%E1%84%8C%E1%85%B5%E1%84%92%E1%85%AE%E1%86%AB%20fd651860ca8046d3b0b4f08c4b14a000/Untitled%203.png)

    - 세부 과정
        - 비어 있는 영역에만 새로운 객체가 들어간다.
        - 쓰레기가 쌓여 꽉 찬 영역을 우선적으로 청소한다.
        - 꽉 찬 영역에서 라이브 객체를 다른 영역으로 옮기고, 꽉 찬 영역은 깨끗하게 비운다.
        - 이렇게 옮기는 과정이 조각 모음의 역할도 한다.
    - 일시 정지 시간을 줄이기 위해 병렬로 GC 작업을 한다. 각각의 스레드가 자신만의 영역을 잡고 작업하는 방식
        - 일시 정지 시간을 최소화하지만, 완전히 없애지는 못하기 때문에, 실시간(real-time) GC가 아니다.

### 2.6 버전 별 default GC 방식

- JDK 8 까지 default GC는 parallel GC
- JDK 9 이후의 default GC는 G1 GC

---

## 부가적인 내용

- 바이트 코드 : 바이트 코드는 가상 머신이 이해할 수 언어
- 바이너리 코드 : CPU가 이해할 수 있는 언어
- JDK와 JRE
    - 실행 환경만 있는 JRE와 JRE를 포함하고 개발에 필요한 라이브러리 등을 추가적으로 더 포함하고 있는 JDK가 있다.
    - [Java 버전 11부터는 JDK만 나온다.](https://stackoverflow.com/a/53733414)
- JDK의 유료화
    - Java 언어 자체는 무료이지만, 개발 도구가 유료화된 것이다.
    - OpenJDK의 배급사가 많이 있다.
    - JVM 및 GC는 JDK 안에 포함되어 있기 때문에, JVM 및 GC도 배급사마다 시간이 갈수록 조금씩 차이가 발생될 거라는 생각이 들었고, [참고 블로그](https://engineering.linecorp.com/ko/blog/line-open-jdk/)에서 해당 사항과 관련하여 언급된 부분이 있다.

## 참고 자료

- [https://d2.naver.com/helloworld/1329](https://d2.naver.com/helloworld/1329)
- [https://johngrib.github.io/wiki/java-g1gc](https://johngrib.github.io/wiki/java-g1gc/)
- [https://johngrib.github.io/wiki/java-gc-tuning/](https://johngrib.github.io/wiki/java-gc-tuning/)