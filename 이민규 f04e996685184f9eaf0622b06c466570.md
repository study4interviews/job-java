# 이민규

## Garbage Collector

- 프로그래머가 **동적으로 할당한 메모리 영역** 중 더 이상 쓰이지 않는 영역을 **자동으로 찾아내어**

    **해제**하는 기능 → 1959년 John McCarthy가 처음 만듬

- FORTRAN이나 C 언어는 프로그래머가 메모리를 동적으로 할당한 뒤 수동으로 해제까지 해 줘야

    했기때문에, 메모리가 필요없어진 뒤에도 해제를 하지 않아 메모리 누수가 생기거나, 거꾸로 

    해제했던 메모리를 다시 사용하거나하는 등 수 많은 버그가 양산

## 작동 방식에 따른 GC 분류

### **추적기반 쓰레기 수집(Tracing Garbage Collection)**

- 가장 많이 사용되는 방식으로 대부분 GC라고 하면 이를 가리킨다.
- 프로그램을 실행하다가 특정한 타이밍에 현재 할당된 모든 메모리를 조사하여 분류한 뒤, 접근이 불가능한 메모리를 해제시키는 방법
- 표시하고 쓸기(mark and sweep), 삼색 기법(tri-color marking), **세대 단위 쓰레기 수집기법** 등

### **참조 횟수 카운팅 쓰레기 수집(Reference Counting Garbage Collection)**

- 다른 메모리가 어떤 메모리를 얼마나 많이 참조하는지 횟수를 세어서 접근 가능과 불가능을 나누는 방법
- 한 메모리에서 다른 메모리를 참조하면 그 다른 메모리의 참조 횟수에 1을 더하고 참조를 중단

    하면 참조 횟수에 1을 뺀다. 0이 되면 해당 메모리에 접근이 불가능 하므로 메모리를 해제한다.

- 오버헤드와 순환 참조의 단점을 가짐
    - **오버헤드** : 모든 대입문에 참조 횟수를 변경하도록 작성해야 하는데 이로 인한 오버헤드가

        발생

    - **순환 참조** : A→B, B→A 같은 참조 관계가 있고 A와 B가 모두 외부에서 접근 불가능한 상황을

        의미. 두 메모리 모두 접근 불가능한 메모리이지만 참조 횟수는 1이므로 그대로 메모리 누수

        가 된다.

    - python은 이 문제를 해결하기 위해 추적 기반 GC를 병행하여 사이클 검사를 따로 실시

### 세대 단위 쓰레기 수집

### Java SE 8 GC tuning guide 중 일부

> *An object is considered garbage when it can no longer be reached from any pointer in the running program. The most straightforward garbage collection algorithms iterate over every reachable object. Any objects left over are considered garbage. The time this approach takes is proportional to the number of live objects, which is prohibitive for large applications maintaining lots of live data.*

***가장 간단한 형태의 가비지 컬렉션 알고리즘은 접근 가능한 모든 객체를 순회하는 것입니다. 순회가 끝난 후에 남아있는 객체를 쓰레기로 판단하는 방식입니다. 그런데 이런 방법을 쓰면 살아있는 객체의 수에 비례하는 시간이 소요되므로, 수많은 라이브 데이터를 관리하는 규모가 큰 애플리케이션에서는 절대 사용하면 안됩니다.***

> *The virtual machine incorporates a number of different garbage collection algorithms that are combined using generational collection. While naive garbage collection examines every live object in the heap, generational collection exploits several empirically observed properties of most applications to minimize the work required to reclaim unused (garbage) objects.*

***가상 머신은 generational collection으로 다양한 가비지 컬렉션 알고리즘을 통합해 사용합니다. 간단한 형태의 가비지 컬렉션은 heap의 모든 라이브 객체를 검사하지만, generational collection은 경험적으로 파악한 대부분의 애플리케이션들이 공통적으로 갖고 있는 특성들을 활용해 쓰레기 객체를 처리하는 데 필요한 작업량을 최소화합니다.***

> *The most important of these observed properties is the weak generational hypothesis, which states that most objects survive for only a short period of time.*

***이러한 경험적으로 파악한 특성 중 가장 중요한 것은 '약한 세대 가설'입니다. 이 가설은 객체 대부분이 아주 짧은 시간 동안만 살아남는다는 내용입니다.***

> *To optimize for this scenario, memory is managed in generations (memory pools holding objects of different ages). Garbage collection occurs in each generation when the generation fills up. The vast majority of objects are allocated in a pool dedicated to young objects (the young generation), and most objects die there. When the young generation fills up, it causes a minor collection in which only the young generation is collected; garbage in other generations is not reclaimed. Minor collections can be optimized, assuming that the weak generational hypothesis holds and most objects in the young generation are garbage and can be reclaimed. The costs of such collections are, to the first order, proportional to the number of live objects being collected; a young generation full of dead objects is collected very quickly. Typically, some fraction of the surviving objects from the young generation are moved to the tenured generation during each minor collection. Eventually, the tenured generation will fill up and must be collected, resulting in a major collection, in which the entire heap is collected. Major collections usually last much longer than minor collections because a significantly larger number of objects are involved.*

***이 시나리오를 최적화하기 위해, 메모리는 여러 generation 으로 관리됩니다. 각 세대가 꽉 채워질 때 가비지 컬렉션이 발생하는 것입니다. 대부분의 객체는 young generation에서 할당되고 또 그곳에서 죽게 됩니다. young generation이 가득 차면 young generation만을 대상으로 하는 마이너 컬렉션이 발생합니다. 이 때 다른 세대의 가비지는 처리되지 않습니다. 마이너 컬렉션은 '약한 세대 가설'을 전제로 최적화된 것입니다. 컬렉션의 비용은 수집되는 살아있는 객체의 수에 비례하므로, 죽은 객체들로만 가득찬 young generation은 매우 빠르게 수집되기 때문입니다. 일반적으로, young generation에서 살아남은 객체들 중 일부는 각각의 마이너 컬렉션 동안 tenured generation으로 옮겨집니다. 결과적으로 tenured generation은 채워지게 되고, 컬렉션의 대상이 되어, 힙 전체를 수집하는 메이저 컬렉션이 발생하게 됩니다. 메이저 컬렉션은 마이너 컬렉션보다 더 오래 걸리는 편인데, 더 많은 객체가 관련되어 있기 때문입니다.***

> reference : GC ROOT의 종류 [https://duongame.tistory.com/114](https://duongame.tistory.com/114)

- 세대 단위 쓰레기 수집은 약한 세대 가설을 기반으로 설계되었다.

**Weak Generation Hypothesis**

1. **대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.**
2. **오래된 객체에서 젊은 객체로의 참조는 아주 적게 발생한다.**
- 이 가설의 장점을 최대한 살리기 위해 **물리적 공간을 Young 영역과 Old 영역으로 나누었다.**
    - Young 영역 : **새롭게 생성한 객체가 위치**
    - Old 영역 : **접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 복사되는 공간.** Young 영역보다 GC는 적게 발생하지만 훨씬 많은 객체가 관여하므로 시간은 더 오래걸린다.

### Young 영역의 구성

- 하나의 Eden 영역과 2개의 Survivor 영역 총 3개로 구성된다.
- 각 영역의 처리 절차를 순서대로 기술하면 다음과 같다.
    1. 새로 생성한 대부분의 객체는 Eden 영역에 위치한다.
    2. Eden 영역에서 GC가 한 번 발생한 후 살아남은 객체는 Survivor 영역 중 하나로 이동된다.
    3. Eden 영역에서 GC가 발생하면 이미 살아남은 객체가 존재하는 Survivor 영역으로 객체가 계속 쌓인다.
    4. 하나의 Survivor 영역이 가득 차게 되면 그 중에서 살아남은 객체를 다른 Survivor 영역으로 

        이동한다. 그리고 가득 찬 Survivor 영역은 아무 데이터도 없는 상태로 된다.

    5. 이 과정을 반복하다가 계속해서 살아남아 있는 객체는 Old 영역으로 이동하게 된다.
- **Young 영역에서 발생한 GC를 Minor GC라고 일컫는다.**
- **이 절차에서는 Survivor 영역 중 하나는 반드시 비어 있는 상태로 남아 있어야 한다.**
- **Minor GC가 발생할 때 Old 영역의 객체는 관여하지 않으므로 Old 객체가 Young 영역의 객체를**

    **참조한다면 이를 체크할 수 있는 별도의 방법이 존재해야 한다.**

## Minor GC 과정

### Eden  에서 Survivor 영역으로

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled.png)

- Eden과 Survivor 0 이 꽉 찬 상태이다.
- Eden이 꽉 찼으므로 Minor GC가 발생한다.
- JVM이 Suspend 상태(Stop-the-world)로 들어간다.
- 쓰레기와 쓰레기 아닌 것을 구분해야 하므로, Mark 작업을 시작한다.

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%201.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%201.png)

- Mark 작업을 끝낸 결과, A, B, C가 쓰레기가 아니라는 표시를 달게 되었다.

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%202.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%202.png)

- A, B, C를 Survivor 1 영역으로 복사했다.

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%203.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%203.png)

- Eden과 Survivor 0 을 깨끗하게 비워버린다.
- JVM의 Suspend 상태가 해제된다.

### Survivor에서 Old 영역으로 Promotion

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%204.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%204.png)

- Mark 작업을 마친 후 위와 같은 상태가 되었다고 하자.
- M을 여러 차례의 GC 에서 살아남은 나이가 많은 객체라 하자.

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%205.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%205.png)

- Survivor 0 에 A, B가 복사되었다.
- Old 영역에 M이 복사되었다. Promotion 된 것이다.
- Minor GC에서 살아남아 Survivor로 이동할 때마다 객체의 Age 가

    증가하는데, 이 Age가 일정 이상이 되면 Old 영역으로 이동하게 된다.

- Promotion의 기준이 되는 Age는 `XX:MaxTenuringThreshold` 옵션으로 설정할 수 있다.
- Java SE 8 에서의 default 값은 15 이다. 설정 가능한 범위는 0 ~ 15

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%206.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%206.png)

- Eden과 Survivor 1 이 깨끗하게 비워진다.

## GC의 종류와 변화

- Serial GC
- Parallel GC
- Parallel Old GC(Parallel Compacting GC)
- Concurrent Mark & Sweep GC(이하 CMS)
- G1(Garbage First) GC

### **Mark-Sweep-Compaction Algorithm**

- 서로 다른 다양한 GC에서 사용되는 알고리즘. 기본적인 GC 과정
    - 사용되지 않는 객체를 식별하는 작업(Mark)
    - 사용되지 않는 객체를 제거하는 작업(Sweep)
    - 파편하된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction)

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%207.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%207.png)

### Serial GC

- 한 개의 스레드만으로 순차적으로 동작하는 GC
- **Java가 처음 등장했던 90년대 후반의 PC들은 메모리나 CPU Core**

    **가 부족했기에 당시에 맞게 사용하던 방식**

### Parallel GC

- Serial GC를 사용하던 시절보다 PC의 메모리도 넉넉해지고 Core도

     많아졌기 때문에 **Serial GC를 멀티스레드로 실행**한 방법

- GC를 처리하는 동안 프로세스가 모두 멈춰버리는 Stop-The-World

    시간도 단축됨

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%208.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%208.png)

### Parallel Old GC

- Parallel GC에서 Old GC 알고리즘을 개선한 버전
- 이전 Parallel GC에서는 Young 영역의 GC만 병렬로 처리했지만 Old 영역에서도 병렬로 수행할 수 있도록 개선
- Mark-Sweep-Compaction 알고리즘에서 Mark-Summary-Compaction 알고리즘으로 변경

### Concurrent Mark-Sweep GC

- STW 시간을 최소화 하는데 초점을 맞춘 GC 방식
- GC 대상을 파악하는 과정이 복잡한 여러단계로 나누어 수행되기 때문에 다른 GC 대비 CPU 사용량이 높다
- Initial Mark → Concurrent Mark → Remark → Concurrent Sweep 과정
    - Initial Mark : 탐색을 시작하는 객체(GC Root)에서 참조 Tree상 가장 가까운 객체만 1차적으로 찾아가며 객체라 GC 대상인지 판단. 탐색 깊이가 얕기 때문에 STW 발생 기간이 매우 짧음
    - Concurrent Mark : STW 현상 없이 진행되며, Initial Mark 참조 가능으로 판별된 객체들을 따라가며 GC 대상을 추가적으로 확인 why?? 왜 다른 스레드를 중지시키지 않아도 되는가??
    - Remark : Concurrent Mark 단계를 검증. 어떤방식으로?????
    - Concurrent Sweep : STW 없이 Remark 단계에서 검증 완료된 GC 객체들을 메모리에서 제거

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%209.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%209.png)

### G1 GC

- 큰 힙 메모리에서 짧은 GC 시간을 보장하는데 목적을 둔 방식
- 앞서 보았던 Eden, Survivor, Old 영역이 존재하지만 고정된 크기로 고정된 위치에 존재하는 것이

    아니며, 전체 힙 메모리 영역을 Region이라는 특정한 크기로 나누어서 각 Region의 상태에 따라 

    역할(Eden, Survivor, Old)이 동적으로 부여되는 상태

![%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%2010.png](%E1%84%8B%E1%85%B5%E1%84%86%E1%85%B5%E1%86%AB%E1%84%80%E1%85%B2%20f04e996685184f9eaf0622b06c466570/Untitled%2010.png)

- 상세 자료 : [https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html](https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)