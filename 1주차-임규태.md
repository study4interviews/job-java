# 1주차 임규태

## Singleton

1. Eager Initialization
    - 장점 : Class Loading 시점에 객체가 생성되어 Thread-safe
    - 단점 : Singleton 객체를 사용하지 않아도 Class 참조 시점에 Class Loading되어 객체가 생성되기 때문에 메모리 비효율적일 수 있음 ⇒ Class 참조를 하면 사용하는거 아닌가? EagerInitalization EI;

    ```java
    package SingleTonExample;
     
    public class EagerInitialization {
     
        //private static으로 선언
        private static EagerInitialization instance = new EagerInitialization();
         
        //생성자
        private EagerInitialization() {}
         
        //인스턴스 리턴
        public static EagerInitialization getInstance() {
            return instance;
        }
     
    }
    ```

2. Lazy Initialization
    - 장점 : Class가 실제로 사용되는 시점에 객체가 생성됨
    - 단점 : Multi Thread 환경에서 객체가 여러개 생성될 수 있음

    ```java
    package SingleTonExample;
     
    public class LazyInitialization {
     
        private static LazyInitialization instance;
     
        private LazyInitialization(){}
         
        public static LazyInitialization getInstance(){
            if(instance == null){
                instance = new LazyInitialization();
            }
            return instance;
        }
     
    }
    ```

3. Thread-safe Lazy Initialization
    - 장점 : `synchronized` 를 통해 Thread safe하게 변경한 Lazy Initialization
    - 단점 : 여러 Thread에서 `getInstance()` 를 호출할 때 Lock,Unlock 비용이 발생, 처리도 늦어짐

    ```java
    package SingleTonExample;
     
    public class ThreadSafeLazyInitialization{
     
        private static ThreadSafeLazyInitializationinstance;
     
        private ThreadSafeLazyInitialization(){}
         
        public static synchronized ThreadSafeLazyInitializationgetInstance(){
            if(instance == null){
                instance = new ThreadSafeLazyInitialization();
            }
            return instance;
        }
     
    }
    ```

4. Thread-safe Lazy Initialization + Double check Locking
    - 장점 :  `synchronized` 를 *instance == null* 인 경우에만 걸어 객체가 생성된 후에는 바로 객체를 return하여 Lock에 드는 비용을 줄일 수 있음

    ```java
    package SingleTonExample;
     
    public class ThreadSafeLazyInitialization {
     
        private static volatile ThreadSafeLazyInitialization instance;
     
        private ThreadSafeLazyInitialization(){}
         
        public static ThreadSafeLazyInitialization getInstance(){
            //Double-checked locking
            if(instance == null){
                synchronized (ThreadSafeLazyInitialization.class) {
                    if(instance == null)
                        instance = new ThreadSafeLazyInitialization();
                }
     
            }
            return instance;
        }
    }
    ```

5. Initialization on demand holder
    - 장점 : Eager Initialization의 사용유무에 상관없이 객체를 생성하던 단점을 보완함 ⇒ `getInstance()` 를 호출하기 전에는 객체가 생성되지 않는다. `getInstance()` 를 호출한 시점에 내부 static class가 로딩되어 Thread safe함.
    - 가장 보편적으로 사용되는 방식

    ```java
    package SingleTonExample;
     
    public class InitializationOnDemandHolderIdiom {
     
        private InitializationOnDemandHolderIdiom(){}
         
        private static class SingleTonHolder{
            private static final InitializationOnDemandHolderIdiom instance = new InitializationOnDemandHolderIdiom();
        }
         
        public static InitializationOnDemandHolderIdiom getInstance(){
            return SingleTonHolder.instance;
        }
    }
    ```

6. Enum Initialization (??)
    - 장점 :
        1. 구현이 쉽다.
        2. Enum 은 태생자체가 스레드 세이프하게 구현되었다. (그렇다고 Enum 내부에 사용자가 구현하는 메소드들도 스레드 세이프가 보장되는 것은 아니다.)
        3. 직렬화/역직렬화 에 대한 처리가 필요없다.
    - 단점 : Eager Initialization과 같은 단점을 가진다 ⇒ 사용하지 않아도 메모리에 올라온다.

    ```java
    package SingleTonExample;
    public enum EnumSingleTon {
     
            INSTANCE;
            public void excute(String arg){
                //...code
            }
    }
    ```

### 참조

[디자인패턴 - 싱글톤 패턴](https://yaboong.github.io/design-pattern/2018/09/28/thread-safe-singleton-patterns/)

[What are the differences between Stateful,Stateless, and Singleton Beans? When to use each of them ? (Giving example would be recommended) - Bayt.com Specialties](https://specialties.bayt.com/en/specialties/q/289787/what-are-the-differences-between-stateful-stateless-and-singleton-beans-when-to-use-each-of-them-giving-example-would-be-recommended/)

---

## 추상클래스 vs 인터페이스 (Java 8 기준)

- `추상클래스`와 `인터페이스`는 인스턴스화 하는 것은 불가능하며, 구현부가 있는 메소드와 없는 메소드 모두 가질 수 있다는 점에서 유사하다.
- `인터페이스`에서 모든 변수는 기본적으로 public static final 이며, 모든 메소드는 public abstract 인 반면
`추상클래스`에서는 static 이나 final 이 아닌 필드를 지정할 수 있고, public, protected, private 메소드를 가질 수 있다.
- `인터페이스`를 구현하는 어떤 클래스는, 다른 여러개의 인터페이스들을 함께 구현할 수 있다. 
`추상클래스`는 상속을 통해 구현되는데,
자바에서는 다중상속을 지원하지 않으므로 추상클래스를 상속받은 서브클래스는 다른 클래스를 상속받을 수 없다.
- 추상클래스, 인터페이스의 적절한 사용 케이스
    1. `추상클래스`
        - 관련성이 높은 클래스 간에 코드를 공유하고 싶은 경우
        - 추상클래스를 상속받은 클래스들이 공통으로 가지는 메소드와 필드가 많거나, public 이외의 접근제어자(protected, private) 사용이 필요한 경우
        - non-static, non-final 필드 선언이 필요한 경우. 즉, 각 인스턴스에서 state 변경을 위한 메소드를 선언할 수 있다.
    2. `인터페이스`
        - 서로 관련성이 없는 클래스들이 인터페이스를 구현하게 되는 경우에 사용한다. 예를 들어, Comparable, Cloneable 인터페이스는 여러 클래스들에서 구현되는데, 구현클래스들 간에 관련성이 없는 경우가 대부분이다.
        - 특정 데이터 타입의 행동을 명시하고 싶은데, 어디서 그 행동이 구현되는지는 신경쓰지 않는 경우.
        - 다중상속을 허용하고 싶은 경우
- 인터페이스에게도 다중상속이 가능하다

```java
interface B{
}
interface C{
}

interface A extends B,C{

}

class D implements A{
  // 구현 필수
}

```

### 예제

- `Unit`을 만들고 싶은 상황
- `Unit`은 마린, 탱크 등 다양한데 Move는 속성이 같을 것이다.

```java
class GameBot{
	go(Object unit)
}

```

- `Object`로는 다 받을 수 있지만 move는 없다
- 공통된 move할 수 있는 `Unit`을 만들 때, `interface`냐 `abstract`냐??

```java
class Unit{
	magicpoint;
  move(int x,int y);
  stop(){
  	// 구현
  }
}

```

- `interface`는 상수(final)로 선언되어 변수의 상태를 변화시킬 수 없다.
- 그렇다면 magicpoint의 값을 바꿀 수 있는 `abstract`가 더 맞을것이다.

```java
class Marine extends Unit{
	move(int x,int y){
   	// 다리로 이동 구현
   }
   steampack(){
   	// 스팀팩 구현
   }
}
class Tank extends Unit{
	move(int x,int y){
   	// 바퀴로 이동 구현
   }
   siegeMode(){
   	// 구현
   }
}

```

### 참조

[[JAVA] 추상클래스 VS 인터페이스 왜 사용할까? 차이점, 예제로 확인 :: 마이자몽](https://myjamong.tistory.com/150)

---
