# 최지우 - Collection

[https://www.youtube.com/watch?v=SLifMOhW1VA](https://www.youtube.com/watch?v=SLifMOhW1VA)

# 테코톡 정리

## Java Collections Framework

- 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합.

### 왜 프레임워크일까?

[src/main/java/zoomba/lang/core/collections/ZList.java · master · natus homo / zoomba](https://gitlab.com/non.est.sacra/zoomba/blob/master/src/main/java/zoomba/lang/core/collections/ZList.java)

[src/main/java/zoomba/lang/core/collections/ZHeap.java · master · natus homo / zoomba](https://gitlab.com/non.est.sacra/zoomba/blob/master/src/main/java/zoomba/lang/core/collections/ZHeap.java)

[Why is Collection in Java called a framework, but not a library (It seems counter intuitive to the definition of a framework which follow...](https://www.quora.com/Why-is-Collection-in-Java-called-a-framework-but-not-a-library-It-seems-counter-intuitive-to-the-definition-of-a-framework-which-follows-the-Dont-call-us-well-call-you-principle)

[Collections Framework Overview](https://docs.oracle.com/javase/8/docs/technotes/guides/collections/overview.html)

- Collection framework의 기틀이 되는 **인터페이스들이 존재. (**예 : List<E>, Collection<E>)
    - 인터페이스를 기반으로 세워진 프레임워크 및 구현체 모음.
    - collection을 다루기 위한 통합 아키텍쳐.
- 일반적으로 기대하는 IoC의 형태라기 보다는, 생태계의 기틀을 잡아주는 Interfaces등을 제공.
- 물론 자세한 ArrayList, LinkedList같은 구현체들은 라이브러리 형태로 사용 할 수 있음.

## JFC 도입 이유

JFC 도입 이전에 데이터를 그룹핑 하는 방법

- Array : []
- Vector : elementAt();
- Hashtable : get()

여러가지 목적에 따른 collection마다 접근 방식이 다름 ⇒ 공통적인 명세를 따르는 Collection의 생태계(프레임워크) 를 만들고, 그것을 잘 활용할 수 있도록 공개된 **공통 인터페이스 제정.**

## Collection

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__7.25.34.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__7.25.34.png)

- Iterable 을 상속한다.
    - Iterable은 `iterator()` 를 구현해야한다.
    - Collection을 훑을 수 있는 표준 적인 방법을 제공한다.

     

## List

- 순서가 있는 데이터의 집합
- List인터페이스의 구현 클래스:
    - ArrayList vs LinkedList

    [Array vs Linked List Data Structures](https://levelup.gitconnected.com/array-vs-linked-list-data-structure-c5c0ff405f16)

    - ArrayList : 크기가 가변적인 선형 리스트. 저장 용량이 존재, 이 용량을 넘어서면 자동으로 용량을 증가 시킴. 기본용량은 10.
        - 맨 끝에 element를 추가할 때 는 O(1)
        - 중간에 element 추가 삭제시 O(N) // 한칸씩 밀어야 하기 때문에.
        - Contiguous 하게 할당 됨.
        - 정적으로 사이즈를 잡아놓고 시작함. 사이즈가 늘릴 때는, 새롭게 복사.
        - **random access data structure** (or direct access)

        [Why sequential access is faster than random access?](https://cs.stackexchange.com/questions/86289/why-sequential-access-is-faster-than-random-access)

    - LinkedList :
        - 메모리의 빈공간에 할당 됨 (Non-contiguous).
        - 가변적으로 늘어날 수 있음.
        - add(index) remove(index)는 O(N)이 걸리지만, ArrayList와는 다른 이유로 O(N) 이다.
            - index까지 가는데 걸리는 시간, 탐색비용.
        - **sequential access data structure**
    - Vector
        - ArrayList와는 기능상 거의 동일하지만, add/remove등에 synchornized가 붙어있다.
        - add, remove시에는 thread-safe하게 추가할 수 있다.
        - 레거시 클래스이기 때문에, 사용하지 않는다.
        - synchronized가 된 자료구조를 위해서는 Collections.synchronizedList(new ArrayList<>()) 등을 활용한다.
    - Stack
        - Vector를 사용하는 LIFO 클래스
        - 따라서, 오라클 문서에서는 레거시 클래스인 Stack대신 Deque 인터페이스와 Deque 구현체를 사용하도록 권장.
    - Queue
        - FIFO 방식의 구조를 가진 자료구조 이지만, JFC에서 Queue는 인터페이스.

            ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__8.10.03.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__8.10.03.png)

    - PriorityQueue
        - FIFO 방식이 아닌 특정 우선순위에 따라서 요소가 먼저 나가는 방식
        - Comparator나 Comparable을 활용해 우선순위를 설정.
    - Deque
        - 큐의 양쪽 끝에서 추가와 삭제가 일어날 수 있는 구조
        - ArrayDeque
            - 사이즈 제한이 없는 가변배열.
            - null요소는 저장 불가.
            - 원형 큐 방식으로 구현
            - Stack이나 LinkedList보다 빠르다.

## Map

- key와 value를 쌍으로 저장
- key는 중복 불가. value는 중복 가능.
- 데이터의 순서를 보장하지 않음.
    - 물론 금지된것은 아니다.
- 키를 기반으로 찾기 때문에 빠름.
- HashTable
    - 레거시 클래스
    - key, value **둘다** 널값이면 안됨.
    - 대부분의 메소드가 동기화 처리되어있다는 특징을 가지고있음.

        ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__8.26.30.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__8.26.30.png)

- HashMap
    - HashTable을 보완한 클래스.
    - 멀티 쓰레드 환경에서는 concurnetHashMap이라는 동시성이 보장된 자료구조를 사용해야한다.

    [[Java] Java에서 Map 관련 Iterate(반복문) 방법](https://fullstatck.tistory.com/10)

- LinkedHashMap
    - HashMap을 상속받는다.
    - LinkedList를 이용해서 순서를 강제한다.
- TreeMap
    - 'key'를 원하는 방식으로 정렬 가능.
    - 레드블랙트리로 구현되어있음.

## Set

- 중복된 요소를 저장하지 않는다.
- 요소의 저장 순서를 유지하지 않는다
    - 다만, 요소의 저장 순서를 유지하는게 **금지된것은 아니다.**
- 중복된 요소를 걸러내기 위해 equals나 hashCode()등을 활용한다.
- HashSet
    - 해시를 활용하여 검색하기 때문에 빠르다.
    - HashMap instance를 활용해 Set을 구성함.
- LinkedHashSet
    - 입력된 순서를 저장하는 특징
    - LinkedHashMap의 instance를 활용한다.
- TreeSet
    - 특정 기준에 따라 요소를 정렬할 수 있다.
    - TreeMap 기준에 따라 요소를 정렬한다.

[Red-Black Tree | Set 1 (Introduction) - GeeksforGeeks](https://www.geeksforgeeks.org/red-black-tree-set-1-introduction-2/)

## Map이 Collection interface와 Iterable을 상속받지 않는 이유

- Map은 두가지 요소가 존재. Key, Entry
- Collection의 add()는 key를 추가해야할까, entry를 추가해야할까?
- Iterator()는 entry를 순회해야할까 key를 순회해야할까?
    - 이런 모호함때문에, Collection Interface와 Iterable Interface를 상속받지 않는다.
    - 대신 HashSet등으로 교체하여서 순회할 수 있다.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__12.23.49.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__12.23.49.png)

- Collection : 객체들을 그룹핑 한 타입.
- Map : Object사이의 관계를 나타내는 타입.

- Set : Collection, no 중복.
- List : Collection, Element에 순서가 있는 콜렉션.
- Tree (SortedSet, SortedMap) : element를 순서대로 유지한다.

# Collection Interface

Collection<E> is a parameterized interface that represents a generalized grouping of objects of type.

## sub interfaces

- List
- Queue
- Set

### Example : 인터페이스 메소드.

```java
Collection<String> c = new HashSet<>();

// 콜렉션 관련 유틸리티 함수들.
Collection<String> d = Arrays.asList("one", "two"); 
Collection<String> e = Collections.singleton("three");

c.add("zero");
// 모든 d의 엘리먼트를 c에 추가한다.
c.addAll(d);

// 대부분에는 copy constructor가 존재한다. shallow copy가 진행된다.
Collection<String> copy = new ArrayList<String>(c);

c.remove("zero");
// e
c.removeAll(e);
// d 안에 있지 않은 모든 엘리먼트를 제거한다.
c.retainAll(d);
// 모든 엘리먼트를 제거한다.
c.clear();

boolean b = c.isEmpty(); 
int s = c.size(); 

c.addAll(copy);

// equals 메소드를 기반으로 탐색하는 contains.
b = c.contains("zero"); // true
b = c.containsAll(d); // true

// 대부분의 collection은 toString()을 가지고 있다.
System.out.println(c);

Object[] elements = c.toArray();
String[] strings = c.toArray(new String[c.size()]);
// 이 방법도 가능하다!
strings = c.toArray(new String[0]);
```

# Set Interface

- set Interface 비교는 최대한 빠르게 비교하기 위해 efficient한 contains()메소드를 구현하고 있다. (log시간)
- 기본적으로는 정렬 기능은 없는게 목적이지만, 그렇다고 해서 금지된건 아니다 (SortedSet, LinkedHashSet)
- collection 하위에서 추가적으로 추가된 메소드는 없지만, 단 add()와 addAll()에서 중복된 값이 들어온다면 삽입하지 않는다.

## Set Implementation

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__2.04.24.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__2.04.24.png)

# List Interface

- Each element of a list has a position in the list, and the List interface defines methods to query or set the element at a **particular position, or index**.

### subList

- subList() method that returns a List object that represents just the specified range of the original list

```java
List<String> words = Arrays.asList("hello", "world", "b","c","d"); 
List<String> sub = words.subList(1,3); // second and third elements 
System.out.println(words);
sub.set(0, "hi");
System.out.println(sub);
System.out.println(words);
```

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__2.20.11.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__2.20.11.png)

- Implementations that provide efficient random access implement the **RandomAccess marker interface.**

    ```java
    if (!(l instanceof RandomAccess)) l = new ArrayList<?>(l);
    ```

# Map Interface

- The Map interface defines an API for defining and querying mappings. Map is part of the Java Collections Framework, **but it does not extend the Collection interface, so a Map is a little-c collection, not a big-C Collection**
- The general performance expectation for Map implementations is that these three basic methods are **quite efficient:** **they should usually run in constant time and certainly no worse than in logarithmic time.**

### 순회방법

```java

// The Map.Entry<K,V> type represents a single key/value pair in a map
for(Map.Entry<String,Integer> pair : m.entrySet()) {
// Print out mappings
	System.out.printf("'%s' ==> %d%n", pair.getKey(), pair.getValue()); // And increment the value of each Entry 
	pair.setValue(pair.getValue() + 1);
}
for(String key : m.keySet()) System.out.println(key);
for(Integer value: m.values()) System.out.println(value);
```

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__2.28.50.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__2.28.50.png)

### EnumMap

- Enum을 키값으로 활용하는 Map
- Enum을 사용한다면 효율적으로 사용하는것이 특징.

### IdentifyHashMap

- equals 대신 ==를 이용해서 hashMap 을 구성
- 실수할 확률이 많으니 사용하지마라.
- 

```java
for(int i = 0; i<numOfCommand; i++) {
                st.nextToken();
                int start = Integer.parseInt(st.nextToken());
                int num = Integer.parseInt(st.nextToken());
                ListIterator<String> iter = list.listIterator(start);
                for(int j = 0; j<num; j++) iter.add(st.nextToken());
                
            }
```

# Queue Interface

- 큐의 대표적 메소드들과 특징.

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__8.41.09.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__8.41.09.png)

    [https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html](https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html)

- Exception은 Unchecked Exception이기 때문에 따로 try-catch문을 강제하진 않는다.

# BlockingQueue Interface

- blocking put()과 take()를 정의.
- put()은 큐에 엘리먼트를 추가하지만, 공간이 없으면 기다렸다가 추가한다.
- take()는 큐의 헤드에서 데이터를 빼내고, 필요하다면 기다렸다가 뺀다.
- 멀티쓰레드를 기반으로한 알고리즘에 많이 활용되는 자료구조이다. (예 : producer-consumer)

    [Guide to java.util.concurrent.BlockingQueue | Baeldung](https://www.baeldung.com/java-blocking-queue)

# 이번주 면접 질문

1. ArrayList와 LinkedList의 차이, 그리고 시간 복잡도를 비교해보세요.
- 참고

    [When to use LinkedList over ArrayList in Java?](https://stackoverflow.com/questions/322715/when-to-use-linkedlist-over-arraylist-in-java)

    [Java Arraylist Interview Questions | Interview Tips](http://www.codespaghetti.com/arraylist-interview-questions/#top4)

    [](https://marobiana.tistory.com/m/130)

2. 다음은 Java의 DAO코드의 일부이다.  발생할 수 있는 문제점과, 그 해결책을 모두 고르자면?

(출처 : 인프런 - 김영한 스프링 핵심개념)

```java
public class MemoryMemberDao implements MemberDao {

		 private static Map<Long, Member> store = new HashMap<>();

		 @Override
		 public void save(Member member) {
			 store.put(member.getId(), member);
		 }
		 @Override
		 public Member findById(Long memberId) {
			 return store.get(memberId);
		 }
}
```

3.  List 클래스의 인스턴스를 매개변수로 받아 중복된 원소를 제거하고 리턴하는 메서드를 작성해보세요.

(출처 : 자바 퍼즐러 - 60번째 퍼즐)

```java
static <E> List<E> withoutDuplicates(List<E> original) {
	// TODO
}
```

다만 순서는 기존의 List와 같아야합니다. 

예를들어, "spam", "sausage", "spam", "tomato", "spam" 이라면, 

결과는 "spam", "sausage", "bacon"이 되어야 합니다.

- 답

    자바에서는 요소를 넣은 순서를 유지하면서 HashMap클래스 정도의 성능을 내는 Set을 구현한 클래스가 있다. LinkedHashSet을 활용하여 이를 구현할 수 있다. (java 1.4 이후)

    ```java
    static <E> List<E> withoutDuplicates(List<E> original) {
    	return new ArrayList<E>(new LinkedHashSet<E>(original));
    }
    ```

4. 다음을 최적화 하시오.

```java
LinkedList<Integer> list = new LinkedList<>();
for (int i = 0 ; i < 100000 ; i++) {
 list.add(i);
}
int sum = 0;
for (int i = 0 ; i < 100000; i++) {
   sum += list.get(i);
 }
```

- 속도차이

    ```java
    int sum = 0;
    long startTime = System.currentTimeMillis();
    for (Integer i : list) {
     sum += i;
    }
    long endTime = System.currentTimeMillis();
    //Total execution time: 3ms

    long startTime = System.currentTimeMillis();
    for (int i = 0 ; i < 100000 ; i++) {
     sum += list.get(i);
    }
    long endTime = System.currentTimeMillis();
    //Total execution time: 5606ms
    ```

    [For-each문은 For문 보다 얼마나 빠를까?](https://siyoon210.tistory.com/99)

    [https://stackoverflow.com/questions/4767615/java-iterating-a-linked-list](https://stackoverflow.com/questions/4767615/java-iterating-a-linked-list)

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__9.52.12.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20Collection%20da8746671b654e978488b411c7c29434/_2021-04-29__9.52.12.png)