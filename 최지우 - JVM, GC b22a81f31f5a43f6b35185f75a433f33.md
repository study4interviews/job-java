# 최지우 - JVM, GC

# 1주차 피드백.

## 1번 : inner-class static init 으로 싱글톤을 구현할 경우, 어떻게 thread-safe함을 보장하는가?

```java
static class InitializationOnDemandHolderIdiom {
		 
	    private InitializationOnDemandHolderIdiom(){}
	     
	    private static class SingleTonHolder{
	        private static final InitializationOnDemandHolderIdiom instance = new InitializationOnDemandHolderIdiom();
	    }
	     
	    public static InitializationOnDemandHolderIdiom getInstance(){
	        return SingleTonHolder.instance;
	    }
	    
	}
```

> Calling getSingleton() references the inner class, **triggering the JVM to load & initialize i**t. This is thread-safe, since **classloading uses locks.**

> While the implementation is an efficient thread-safe "singleton" cache without synchronization overhead, and better performing than uncontended synchronization.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-05__10.32.06.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-05__10.32.06.png)

[http://literatejava.com/jvm/fastest-threadsafe-singleton-jvm/](http://literatejava.com/jvm/fastest-threadsafe-singleton-jvm/)

### 정리

1. inner-class를 부르며 Class Loading을 trigger한다.
2. class-loading과정은 thread-safe하다. 따라서 한 쓰레드만 무조건 **로드할 수 있다.**

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-02__5.09.46.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-02__5.09.46.png)

3. class-loading과정에서 static-field에 있는것도 모두 로드한다. 이 때, 싱글톤 객체가 생성된다.

## 2번 : volatile 방식에서 volatile을 쓰는것은 왜 중요한지? 왜 다른 방식에선 안쓰는지?

- JVM스펙에 따르면, 각 쓰레드는 로컬 캐시를 쓴다.
- 로컬 캐시에 변수값(상태값)을 저장하기 때문에, 실제로 상태값이 최신값이 아닐 확률이 크다.
- **같은 lock**을 하게 되면 기본적으로 visibility(main memory ↔ working memory sync) 를 보장하게 된다.

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-05__11.20.40.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-05__11.20.40.png)

    Fig 3.1, Java Concurrency in Pratice, p.37.

    > In other words, everything A did in or prior to a synchronized block is visible to B when it executes a synchronized block guarded by the same lock. Without synchronization, there is no such guarantee.

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__6.30.45.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__6.30.45.png)

- 하이라이팅된 코드 라인같은우는 synchronized 블럭 다음에 실행된다고 보장할 수 없다. 따라서 여기서는 volatile을 쓴다.

## 3번 : Lazy init이 가지는 이점은 무엇인가?

```java
static class EagerSingleton {
	    private static EagerSingleton instance = new EagerSingleton();
	    
	    static {
	    	System.out.println("out");
	    }
	    // private constructor
	    private EagerSingleton() {
	    }

	    public static EagerSingleton getInstance() {
	        return instance;
	    }

	    public static void reset() {
				// some logic.
	    }
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		EagerSingleton.reset(); // 여기서클래스 로딩이 일어난다. getInstance()시점에 메모리 공간 확보에 유리하다.
	}
```

## 4번 : volatile을 꼭 써줘야하는가?

- [메인메모리에서 스레드로 값을 가져와 사용할 때에는 read -> load -> use 순서로 진행되며, 스레드에 있는 값을 메인메모리로 가져올 때에는 assign -> store -> write 순서로 진행된다.](https://yaboong.github.io/design-pattern/2018/09/28/thread-safe-singleton-patterns/)

    ```java
    public class DoubleCheckedSingleton {
        private static volatile DoubleCheckedSingleton instance = null;

        private DoubleCheckedSingleton() {}

        public static DoubleCheckedSingleton getInstance() {
            if (Objects.isNull(instance)) {
                synchronized (DoubleCheckedSingleton.class) {
                    if (Objects.isNull(instance)) {
                        instance = new DoubleCheckedSingleton();
                    }
                }
            }
            return instance;
        }
    }
    ```

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__6.23.40.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__6.23.40.png)

- 첫번째 스레드가 instance 를 생성하고 synchronized 블록을 벗어남.

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__6.25.13.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__6.25.13.png)

- 두번째 스레드가 synchronized 블록에 들어와서 null 체크를 하는 시점에서,
    - 첫번째 스레드에서 생성한 instance 가 working memory 에만 존재하고 main memory 에는 존재하지 않을 경우
    - 또는, main memory 에 존재하지만 두번째 스레드의 working memory 에 존재하지 않을 경우

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__6.25.33.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__6.25.33.png)

- 즉, 메모리간 동기화가 완벽히 이루어지지 않은 상태라면
- 두번째 스레드는 인스턴스를 또 생성하게 된다.

# JVM, GC 공부 목적

- 실제로 프로그래밍 할 때, 사용할 것들은 아니고 어플리케이션을 프로파일링 할 때 사용할 수 있다.
    - ClassLoaing시의 문제를 알고 해결할 수 있다.
    - GC의 종류와 특징을 알고, 본인의 어플리케이션의 성격에 유리한 GC를 선택할 수 있는지.
    - Java 환경설정을 셋팅할 수 있고, 관련 문제가 있을경우 어떻게 해결할지 알 수 있다.
    - 우리가 사용하는 GC가 어떤 GC인지 이해해야할 필요가 있다.

# JVM, JRE, JDK

### JVM (java virtual machine)

- **자바 바이트코드를 어떻게 이해할지에 대한 표준 스펙을 의미한다.**
- [https://docs.oracle.com/javase/specs/index.html](https://docs.oracle.com/javase/specs/index.html)
- JVM을 구현하는 구현체들은 많다.
- '플랫폼에 종속적' 이다.
    - Java라는 언어의 동작은 플랫폼 독립적이지만, JVM은 플랫폼에 종속되어있다.

### JRE (java runtime enviroment)

- JVM은 단순히 JVM으로만 배포되지 않는다. 최소한의 배포단위는 JRE.
- JRE의 목적은 **자바 어플리케이션을 실행하는것에 있다.**
    - 따라서 바이트코드를 읽을 JVM과 그 실행을 도울 JRE System Library를 포함한다.

        ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-05__11.37.12.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-05__11.37.12.png)

- JRE구조.

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-05__11.35.42.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-05__11.35.42.png)

- java를 실행하기 위한것들만 들어있기 때문에 java관련 툴 (javac, javap 등은 들어있지 않다. 단 어플리케이션을 실행하기 위한 java 같은 명령어는 들어있다.)
- rt.jar는 런타임에 필요한 다양한 다양한 클래스(라이브러리)의 정보가 담겨있다.
    - Java.thread, Java.util. Java.io. Java.lang...
    - 따라서 이 rt.jar는 반드시 classpath에 속해있어야지 정상적으로 컴파일이 가능하다.

### JDK (java development kit)

- JRE + 자바 개발에 필요한 툴을 포함한 버전이다.
- javap, javac, javadoc, jar 등 이 추가적으로 포함되어있다.
- 오라클에서는 Java SE 11 부터는 JDK 하나로만 배포된다.

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__9.30.01.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__9.30.01.png)

## Java & JVM 언어

- Java는 프로그래밍 언어
    - JDK의 javac를 활용하여 바이트코드로 컴파일 하여서 JVM으로 실행.
- JVM언어는 JVM을 기반으로 동작하는 프로그래밍 언어
    - Kotlin, Scala, Groovy등.
    - JVM에서 실행될 수 있는 바이트코드로 컴파일 되면 JVM 위에서 동작시킬 수 있다.

# JVM구조

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__10.09.41.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__10.09.41.png)

인프런, 더 자바 코드를 조작하는 다양한 방법.

## 클래스 로더 시스템

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__11.59.54.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__11.59.54.png)

- .class에서 바이트코드를 읽고 메모리에 저장하는 역할을 담당.

### 로딩

- .class파일을 읽고, 적절한 바이너리 데이터를 만들어서 **메소드 영역에** 저장한다.
- 메소드 영역에 저장되는 메타데이터는 FQCN, 클래스, 인터페이스, 이늄, 메소드와 변수등을 저장한다.
- **로딩이 끝나면 이 객체를 `Class` 타입으로 생성하여 '힙'에 저장한다**.

    ```java
    App.class 
    App app = new App();
    app.getClass() // Class타입으로 생성된 
    ```

- 순서
    - 제일 부모에게 요청을 한다.
    - 부모가 못읽으면 자식이 읽는다.
    - 최종까지 왔는데 못읽으면 ClassNotFoundException을 던진다.

**📕  부트스트랩 클래스로더**

- JAVA_HOME/lib 모듈 (java 9) 혹은 rt.jar (java8)는 코어 자바 API를 (rt.jar에 있는것들) 로딩하는 목적에 있다. 예) main()을 로드할 때 java.lang

**📕  익스텐션(플랫폼) 클래스로더**

- JAVA_HOME/lib/ext 폴더 또는 java.ext.dirs 시스템 변수에 해당하는 위치에 있는 클래스를 읽는다.

**📕  어플리케이션 클래스로더**

- 저 두가지 외에 클래스를 모든 클래스를 로딩한다고 생각하면 좋다. -classpath에 속한 모든 클래스가 해당한다.

[자바 클래스 로딩, 그리고 리플렉션](https://velog.io/@agugu95/%EC%9E%90%EB%B0%94-%ED%81%B4%EB%9E%98%EC%8A%A4-%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%86%8D%EB%8F%84-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%EA%B8%B0%EB%B2%95%EB%93%A4)

```java
Classloader classLoader = App.class.getClassLoader();
System.out.println(classLoader); // AppClassLoader
SYstem.out.println(classLoader.getParent()); // platformClassLoader
SYstem.out.println(classLoader.getParent().getParent()); // null (네이티브 코드로 구현되어있으므로 null이 반환된다)
```

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__2.12.41.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__2.12.41.png)

### 링킹

- verify : .class 파일 형식이 유효한지 체크한다. 만약 변조되어서 해시값이 변경되거나 하면 읽지 않는다.
- prepare : 클래스 static 변수와 기본값에 필요한 메모리를 준비해주는 과정.
- resolve(optional) :심볼릭 메모리 레퍼런스 (논리적으로만 구성해놓고 실제로는 연결 안되어있는 상태)를 실제 힙에 들어있는 레퍼런스로 교체한다. 하지만 optional이라, 실제로 이 과정에서 실행 안되고 사용할 때 일어날 수 있다.

```java
Book book = new Book();
=> Book book = Symbolic:book;
```

### 초기화

- static 변수의 값을 할당한다.
- static block을 실행한다.

## 클래스 로딩 타이밍

- 자바의 클래스 로딩은 클래스 참조시점에 JVM에 코드가 링크되고, 실제 로딩에는 Dynamic loading을 거친다.
    - 즉, JVM은 기본적으로 클래스에 대한 정보를 가지고 있지 않고, 실제 클래스 참조 시점에 클래스 정보를 가져온다.
    - C같은 경우 컴파일 시점에 모든 헤더 정보를 가져와 링킹하는 과정과 다르게, JVM은 동적으로 불러온다는 점이 다르다.

### Load time dynamic loading

System, Object,String등 코어 api등을 main()시점에 이미 로딩.

따라서 import java.lang.Object, System등을 할필요 없음.

```java
Public class Hello { 
	Public static void main(String[] args) { 
		System.out.println(“Hello Java”);  
	}  
}
```

### Runtime Dynamic Loading

객체를 참조하는 순간에 동적으로 로딩하는 방식.

객체를 로딩할 정보는 런타임에 전달된다. 

클래스 정보같은경우는 Class Loader Name + Package Name + Class Name를 가지고 class를 판별한다. 따라서 FQCN (Full Qualified Class Name)을 적어줘야지 클래스를 정확히 로딩할 수 있다.

```java
Public class Hello {  
	Public static void main(String[] args) {  
		Class c1 = Class.forName(args[0]); 
	}  
}
```

[programming : 네이버 블로그](https://blog.naver.com/haena910/222150168303)

[4장 - Class Loader](https://www.slipp.net/wiki/pages/viewpage.action?pageId=8880262)

[When a class is loaded and initialized in JVM - Java](https://javarevisited.blogspot.com/2012/07/when-class-loading-initialization-java-example.html#ixzz2ZHoZKA48)

[디자인패턴 - 싱글톤 패턴](https://yaboong.github.io/design-pattern/2018/09/28/thread-safe-singleton-patterns/)

## 메모리

### 어플리케이션에서 공유되는것.

- 메소드 영역 : 클래스 수준의 정보 (클래스 이름, 부모 클래스 이름, 메소두, 변수) 를 저장한다.
- 힙 영역 : 객체를 저장한다.

### 각 쓰레드 끼리만 공유되는것.

- 스택 : 쓰레드마다 런타임 스택을 만들고, 그안의 메소드 호출을 스택프레임이라 부르는 블럭으로 쌓는다. Error message의 stack trace는 이 리스트를 모두 출력해주는것이다.
- PC : 쓰레드마다 쓰레드 내 현재 실행할 스택 프레임을 가리킨다.
- 네이티브 메소드 스택 : 네이티브 메소드 (Java가 아닌 C 등 으로 짜여있는 메소드들) 전용 스택.
    - 네이티브 메소드 스택 - JNI - 네이티브 메소드 라이브러리.
    - 대표적으로 Thread.currentThread()라는 메소드는 C로 구현되어있다.

## 실행엔진

- 인터프리터 : 바이트코드를 한줄씩 실행한다.
- JIT : 인터프리터의 효율을 높이기 위해 반복되는 코드를 체크하고 그것을 네이티브로 바꿔놓는 컴파일러.
- GC : 더이상 참조되지 않은 객체를 모아서 정리한다.
    - throuhput 위주의 gc.
    - stop the world를 줄이는 gc.
        - **Java에서 서버에서 사용할 때는 굉장히 많은 객체들을 생성하고 소멸하기 때문에 stop the world를 줄이는 GC를 사용하는게 유리하다.**

# 인터프리터 & JIT Compiler

JIT는 Just In Time 이라고 하며, 자바 런타임 환경에서 바이트코드의 컴파일을 담당합니다.

JVM은 바이트 코드 해석과 실행을 위해 **인터프리터와** **JIT**를 사용합니다.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/Untitled.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/Untitled.png)

[https://docs.oracle.com/cd/E19620-01/805-4031/6j3qv1oec/index.html](https://docs.oracle.com/cd/E19620-01/805-4031/6j3qv1oec/index.html)

### JIT 을 사용하는 이유.

바이트 코드를 해석&실행**(인터프리팅)의 실행** 과정은 느립니다.

예를들어서,

단 한줄의 코드는 `x=y+(2*x)` 는 아래의 바이트코드로 바뀌고, 6줄의 바이트 코드를 해석 & 실행하기 위해 decoding, fetching, excuting 을 하며 위한 수십~수백개의 명령을 수행해야합니다.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2020-11-19__6.39.41.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2020-11-19__6.39.41.png)

[http://people.cse.iitd.ac.in/~sbansal/csl862-virt/readings/CompileJava97.pdf](http://people.cse.iitd.ac.in/~sbansal/csl862-virt/readings/CompileJava97.pdf)

따라서 가장 좋은 방법은 빠르게 수행할 수 있는 **기계어**로 **번역(컴파일)**을 해서 그 결과를 반복적으로 사용하는 방법입니다. 이러면 수행해야 하는 명령의 수가 줄기 때문에, 퍼포먼스를 늘릴 수 있습니다. 

우리는 완전한 컴파일을 런타임 이전에 하지 않기 때문에 (플랫폼 독립성과, 다양한 안전장치를 확보할 수 있는 방법이기 때문에), **런타임에서 컴파일을 하는 방법을 사용해야 합니다.**

한편, 컴파일링을 런타임에서 도입하기 위해서는, "**컴파일을 하는 시간**" 역시 중요한 고려사항입니다. 

- 런타임에서 컴파일 방법을 사용하려면, 컴파일을 하는 시간이 인터프리팅 (바이트코드 해석 + 수행) 하는 시간보다 빨라야합니다. 만약 그렇지 않다면 굳이 컴파일을 사용할 이유는 없습니다.
- 런타임 컴파일 시간이 길어지면, **처음 앱을 켤 때** 코드를 컴파일 하는데의 시간 (start-up) 시간이 길어져서 앱이 시작될때 까지 유저가 기다려야합니다.
    - 코드 컴파일은 아무래도 초반 앱을 켰을 때 의 상황 (warm-up) 구간에서만 jit의 사용량이 높습니다. 따라서, 최대한 start-up~ warm-up 구간이 길어지지 않도록 적당히 컴파일 활용과 인터프리터 활용에 밸런스를 맞추는것이 중요합니다.

        ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2020-11-19__7.22.56.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2020-11-19__7.22.56.png)

        [http://cr.openjdk.java.net/~vlivanov/talks/2015_JIT_Overview.pdf](http://cr.openjdk.java.net/~vlivanov/talks/2015_JIT_Overview.pdf)

### JIT 컴파일러의 동작방식

JIT 컴파일러는 일반적인 컴파일러처럼 최적화 과정등을 최대한 덜어내고, 컴파일 과정을 빠르게 하여서 실행시키는것에 주안점을 둡니다. 

따라서 JIT은 다양한 **휴리스틱 기법들을** 활용합니다. → 휴리스틱이 멀까용

- 처음 실행되는 or method invocation call count 체크하여 사용이 많이되거나 필요한 메소드를 우선적 컴파일 하기.
- 바이트코드나 생성되는 코드 profile등을 참고하여, 컴파일이 필요한 코드와 필요하지 않은 코드 구분하기.

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2020-11-19__8.52.39.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2020-11-19__8.52.39.png)

    [http://cr.openjdk.java.net/~vlivanov/talks/2015_JIT_Overview.pdf](http://cr.openjdk.java.net/~vlivanov/talks/2015_JIT_Overview.pdf)

    ⇒ 만약 실행되지 않는 부분이라면, 굳이 컴파일 하지 않습니다.

- 자주 수행되는 코드라면 최적화를 나중에 다시 컴파일 수행하기.

# JVM GC

- GC : JVM힙영역에서 사용하지 않는 객체를 정리하는 방식

## 정리 방식

### Mark & Sweep & Compact

1. GC Root 로 부터, 도달할 수 있는 객체와 도달하지 못하는 객체를 구분한다.
    1. GCRoot는 
        1. local variable(stack영역의 데이터들)
        2. method영역의 static data들.
        3. JNI에 의해 생성된 객체들..
2. Reachable Object 와 Unreachable Object로 나눈다. 

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.22.21.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.22.21.png)

3. Unreachable한 객체를 heap에서 제거한다.
4. sweep후에 분산된 객체들을 시작주소로 모아서 메모리 단편화를 막아준다. (알고리즘에 따라 다름)

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.23.57.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.23.57.png)

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.24.04.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.24.04.png)

- 그럼 mark & sweep은 누가 trigger할까?
    - (주기적으로?, 혹은 어떤 trigger하는 알고리즘이 있을까?)
- 그리고 많은 객체들을 대상으로 mark&sweep과정을 하면 느려지지 않을까?
- mark&sweep과정은 thread-safe한가? thread-safe하다면, 프로덕션에서 gc를 빠르게 하기 위해서는 어떻게 하는가?

## Heap의 구조

- young generation : 새로 생성된 객체는 이 영역으로 들어온다.
- old generation: young gen에서 오래 살아남은 객체는 old generation에서 돌아온다.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.24.54.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.24.54.png)

- 새로운 객체가 Eden 영역에 할당된다

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.26.50.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.26.50.png)

- Eden에 할당될 곳이 없다면 ***Minor GC***가 발생한다. 이때, Mark & Sweep이 일어난다.
- 살아남은 객체들은 survivor 로 이동한다.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.27.45.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.27.45.png)

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.33.50.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.33.50.png)

- 살아남은 영역에 있는건 age값이 증가한다.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.34.02.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.34.02.png)

- Age가 어느 임계점에 도달하면 old generation으로 이동한다.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.34.41.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.34.41.png)

- old generation이 꽉차면 **Major GC**가 발생된다!

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.35.32.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__4.35.32.png)

## Major GC & Minor GC

GC의 두가지 가정

1. 대부분의 객체는 금방 GC에 의해 정리될것이다.

    ⇒ 대부분의 객체의 수명은 매우 짧다. 

2. 오래된 객체로의 참조에서 젊은 객체로의 참조는 아주 적게 존재한다.

    ⇒ ?

⇒ 따라서 (위의 가정이 맞다면) 중간중간에 Memory를 위한 짧게 짧게 gc를 해주는게 더 이득이라고 판단할 수 있다.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__5.25.09.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__5.25.09.png)

[https://gyoogle.dev/blog/computer-language/Java/Garbage Collection.html](https://gyoogle.dev/blog/computer-language/Java/Garbage%20Collection.html)

[NAVER D2](https://d2.naver.com/helloworld/1329)

# GC의 종류

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.16.52.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.16.52.png)

- GC가 달성해야할 목표 2가지.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__7.35.52.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__7.35.52.png)

[http://eivindw.github.io/2016/01/08/comparing-gc-collectors.html#:~:text=Throughput - This is the percentage,over long periods of time.&text=Pause-times%2Flatency - This,unresponsive because of garbage collection](http://eivindw.github.io/2016/01/08/comparing-gc-collectors.html#:~:text=Throughput%20%2D%20This%20is%20the%20percentage,over%20long%20periods%20of%20time.&text=Pause%2Dtimes%2Flatency%20%2D%20This,unresponsive%20because%20of%20garbage%20collection).

- Throughput이 낮은 경우 : GC에서 사용하는 시간이 길어지는 경우.
- Throughput이 높은 경우 : GC에서 사용하는 시간이 짧아지는 경우.
- Latency가 높은 경우 : GC가 자주 작업을 멈추게 하는 경우.
- Latency가 낮은 경우 : GC가 전체 작업을 멈추게 하는게 덜하는경우.

## stop the world (pause-time/latency) ?

GC를 실행하기 위해 JVM이 어플리케이션 실행을 멈추는것. (?)

즉, GC를 실행하는 쓰레드 외 다른 쓰레드의 작동이 정지된다.

### Serial GC

- 가장 단순함.
- 한가지의 쓰레드가 GC를 처리함.
- stop-the-world 시간이 길다.
- young 영역에는 mark&sweep
- old영역에는 mark&sweep&compact 과정.
- **서버의 코어가 1개일 때 사용하기 위해 개발됨. (멀티 쓰레드 환경을 고려하지 않고 개발된 GC방식), 100MB정도의 데이터 셋을 다루는 간단한 어플리케이션에서 적합.**

```java
java -XX:+UseSerialGC -jar Application.java
```

### Parallel GC

- minor gc에서는 multi thread를
- stop-the-world시간이 개선됨.
- **Throughput GC 로 유명함.**
- 여러개의 쓰레드로 GC의 오버헤드를 많이 줄여줌.
- CPU가 여러개일 때, 유리하게 동작.
- 그럼에도 불구하고 Application이 멈추는것을 피할 수 없기 때문에, 다른 알고리즘이 개발되었다.
- java8의 기본 gc.

```java
java -XX:+UseParallelGC -jar Application.java

// 사용할 쓰레드의 갯수
-XX:ParallelGCThreads=<N>

// 최대 지연 시간
-XX:MaxGCPauseMillis=<N>
```

### CMS GC

- stop-the-world를 줄이기 위해 고안됨.

    **mark**과정과 **sweep**과정을 concurrent 진행됨.

    ![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__7.09.44.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__7.09.44.png)

    - gc처리 과정과 나머지 쓰레드 처리를 동시에 진행함.
        - initial mark  : GC Root에서 참조하는 객체들만 우선 식별
        - concurrent mark : 이전 단계에서 식별한 객체들이 참조하는 모든 객체 추적.
        - remark : 이전과정에서 식별된 모든 객체를 다시 추적. 업데이트 사항 확인.
        - sweep : 최종적으로 안쓰는객체들 삭제.
    - **low latency gc로 알려져있다.**
    - 동시적으로 진행되므로 CPU소모가 크고, Compaction 단계를 수행하지 않는다.
        - 메모리 파편화가 일어나서 나중에 stop-the-world의 시간이 더 길어질 수 있다.
        - "CMS GC를 사용할 때에는 신중히 검토한 후에 사용해야 한다. 그리고 조각난 메모리가 많아 Compaction 작업을 실행하면 다른 GC 방식의 stop-the-world 시간보다 stop-the-world 시간이 더 길기 때문에 Compaction 작업이 얼마나 자주, 오랫동안 수행되는지 확인해야 한다."
    - Use the CMS collector if your application needs **shorter garbage collection pauses and can afford to share processor resources with the garbage collector when the application is running. (어플리케이션의 리소스가 자주 concurrent하게 돌리기에 충분하고, shorter garbage collection이 필요할 때)**

    ```java
    java -XX:+UseConcMarkSweepGC -jar Application.java
    ```

### Garbage-First Garbage Collection

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.36.40.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.36.40.png)

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.37.19.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.37.19.png)

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.38.54.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.38.54.png)

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.39.27.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.39.27.png)

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.39.43.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.39.43.png)

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.39.59.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/_2021-05-06__8.39.59.png)

- Heap을 일정한 Region으로 나눈다.
- G1 GC는 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다. 그러다가, 해당 영역이 꽉 차면 다른 영역에서 객체를 할당하고 (할당된 영역에만 체크를 하고) GC를 실행한다.
- Region별로 나누어서 관리하기 때문에 파편화 과정을 막을 수 있다.
- The Garbage first collector (G1) introduced in JDK 7 update 4 was designed to better support heaps larger than 4GB.

> "마지막으로 한 가지 더 말하고 싶은 것이 있다. 어떤 서비스에서 A라는 GC 옵션을 적용해서 잘 동작한다고 그 GC 옵션이 다른 서비스에서도 훌륭하게 적용되어 최적의 효과를 볼 수 있다고 생각하지 말라는 것이다."

> "각 서비스의 WAS에서 생성하는 객체의 크기와 생존 주기가 모두 다르고, 장비의 종류도 다양하다. WAS의 스레드 개수와 장비당 WAS 인스턴스 개수, GC 옵션 등은 지속적인 튜닝과 모니터링을 통해서 해당 서비스에 가장 적합한 값을 찾아야 한다"

[https://www.youtube.com/watch?v=Fe3TVCEJhzo&t=315s](https://www.youtube.com/watch?v=Fe3TVCEJhzo&t=315s)

[https://www.youtube.com/watch?v=ORlPH0xqWpY](https://www.youtube.com/watch?v=ORlPH0xqWpY)

[Garbage Collectors - Serial vs. Parallel vs. CMS vs. G1 (and what's new in Java 8) | OverOps](https://www.overops.com/blog/garbage-collectors-serial-vs-parallel-vs-cms-vs-the-g1-and-whats-new-in-java-8/)

[NAVER D2](https://d2.naver.com/helloworld/1329)

[Garbage First Garbage Collector Tuning](https://www.oracle.com/technical-resources/articles/java/g1gc.html)

[](https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf)

[](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.6386&rep=rep1&type=pdf)

[Garbage Collection Optimization for High-Throughput and Low-Latency Java Applications](https://engineering.linkedin.com/garbage-collection/garbage-collection-optimization-high-throughput-and-low-latency-java-applications)

[Comparing GC Collectors](http://eivindw.github.io/2016/01/08/comparing-gc-collectors.html)

[https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf](https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf)

[[Java] 다양한 종류의 Garbage Collection(가비지 컬렉션) 알고리즘 (2/2)](https://mangkyu.tistory.com/119)

# V8 Engine GC

- V8
    - 구글에서 개발한 Javascript전용 오픈소스 엔진
    - Node.js, Chrome에서 Javascript를 실행하는데 사용됨.

![%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/Untitled%201.png](%E1%84%8E%E1%85%AC%E1%84%8C%E1%85%B5%E1%84%8B%E1%85%AE%20-%20JVM,%20GC%20b22a81f31f5a43f6b35185f75a433f33/Untitled%201.png)

[https://teraphonia.tistory.com/800](https://teraphonia.tistory.com/800)