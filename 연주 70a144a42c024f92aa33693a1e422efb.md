# 연주

# Review

lazy singleton with holder

```java
public class LazySingletonClass {

    static {
        System.out.println("LazySingletonClass 의 static 코드 블록...");
    }

    public LazySingletonClass() {
        System.out.println("LazySingletonClass 의 기본 생성자...");
    }

    public LazySingletonClass(String value) {
        System.out.println(value + "LazySingletonClass 의 생성자... String 타입 인자 받음");
    }

    class InnerClass {
        private LazySingletonClass innerClass = new LazySingletonClass("inner 클래스...");
    }

    // 싱글톤 lazy load
    static class StaticInnerClass {
        private static int count;

        private static LazySingletonClass innerClass = new LazySingletonClass("static inner 클래스의 "+  ++count  +"번째 innerClass 객체 생성... " + "\n");

        static {
            System.out.println("static inner 클래스의 static 코드블록...");
        }

        public static void load() {
            System.out.println("static inner 클래스의 static 메소드 : load()");
        }
    }

    // 싱글톤 객체 호출
    public static LazySingletonClass getInstance() {
        return StaticInnerClass.innerClass;
    }

    public static void main(String[] args) {
        System.out.println("메인함수 동작...");

        // 싱글톤 객체 없으면 생성
        LazySingletonClass.getInstance();
        LazySingletonClass.getInstance();

//        LazySingletonClass p = new LazySingletonClass();
//        LazySingletonClass.StaticInnerClass.load();
//        LazySingletonClass ok = StaticInnerClass.innerClass;
//        LazySingletonClass hello = ok.new InnerClass().innerClass;
    }
}
```

→  `LazySingletonClass.getInstance()` 가 연달아 실행되었을 때, 첫 번째 getInstance()만 호출되어 실행되는 것을 알 수 있었습니다.

![%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled.png](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled.png)

# JVM과 GC

[https://www.youtube.com/watch?v=UzaGOXKVhwU](https://www.youtube.com/watch?v=UzaGOXKVhwU)

## 주요 용어

- **환경, 플랫폼 = 운영체제 + CPU 아키텍처 ⭐**

ex) 내 컴 운영체제는 Linux고 CPU는 AMD 라이젠

- **컴파일 플랫폼** : 프로그램을 만들고 있는 컴퓨터 (개발자 컴퓨터)
- **타겟 플랫폼** : 프로그램을 사용할 컴퓨터 (사용자 컴퓨터)

## 플랫폼이 달라질 경우 Java와 C/C++ 대응방식

컴파일 플랫폼과 타겟 플랫폼이 다를 경우 프로그램이 동작하지 않을 수 있다.

- C/C++은 **크로스컴파일**

    타겟 플랫폼에 맞춰 컴파일

- Java은 **JVM**

    자바 **바이트 코드**는 **플랫폼에 상관없이** JVM 위에서 동작

    주의 **⭐ JVM은 타겟 플랫폼에 의존한다**

## JVM

JVM(자바가상머신)이 .java의 바이트 코드를 해당 운영체제가 이해할 수 있는 기계어로 변환하여 전달

**왜 필요?**

- 자바는 **네트워크에 연결된 모든 디바이스에서 작동**하는 것이 목적이었음! 즉, 디바이스마다 운영체제와 하드웨어(CPU, ... 등) 다르기 때문에 플랫폼에 의존적이지 않도록 언어를 만들어야했다. 그래서 이 해결책으로 Java Bytecode를 실행시킬 수 있는 JVM이 필요했다.
- 한정된 메모리를 효율적으로 사용하여 최고의 성능을 내기 위해서

## 자바 코드가 실행되기까지

크게

- Java Virtual Machine(JVM)
- Java Compiler : 개발자가 작성한 코드 의미 분석
- JIT Compiler

![%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%201.png](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%201.png)

## JVM  구조

크게

- **class loader**
- **runtime data area**
- **execution engine**
- native method interface - JNI
- native method libraries

![%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%202.png](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%202.png)

![%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%203.png](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%203.png)

## Class Loader Subsystem

**클래스 로더(Class Loader)**

- **JVM 내로 클래스(.class)파일을 로드**하고, **링크를 통해 배치**하는 작업을 수행합니다. Runtime 시에 동적으로 클래스를 로드합니다. .jar 파일 내 저장된 클래스들을 JVM 위에 탑재하고 사용하지 않는 클래스들은 메모리에서 삭제합니다.
- 자바는 동적 로딩(Dynamic Loading) 을 지원합니다. 따라서 컴파일 타임에 모든 클래스가 로딩되지 않고 필요한 시점에 (런타임 도중) 해당 클래스를 실행하고 로딩합니다. 그 역할을 Class Loader 가 하는것입니다.

## ⭐ **Runtime Data Area**

- JVM 이 Java Bytecode를 실행하기 위해 운영체제로부터 할당받은 메모리 공간입니다.

![%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%204.png](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%204.png)

**PC Register**

- Thread 가 시작될 때 함께 생성되는 공간으로 스레드 마다 하나씩 존재합니다. 스레드가 어떤 부분을 어떤 명령으로 실행해야 할 지에 대한것을 기록하는 부분으로 현재 수행중인 JVM 의 명령 주소를 가집니다 .

**JVM 스택 영역(JVM Stack)**

- 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역입니다. 각종 형태의 변수나 임시 데이터, 스레드나 **메서드의 정보를 저장**합니다. 메소드 호출 시마다 각각의 스택 프레임(그 메서드만을 위한 공간)이 생성됩니다. 이곳에 메서드 안에서 사용되는 값들을 저장합니다. 호출된 매개변수, 지역변수, 리턴 값 및 연산 시 변화하는 값들을 임시로 저장합니다. 메서드 수행이 끝나면 프레임 별로 삭제합니다.

**Native Method Stack**

- 자바 프로그램이 컴파일 되어 생성되는 바이트 코드가 아닌 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역입니다. J**ava 가 아닌 다른 언어로 작성된 코드(C, C++ 등)를 위한 공간**입니다. Java Native interface 로 인해 바이트코드로 변환하여 저장됩니다. 일반 프로그램 처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역입니다.

### Thread가 공유하는 영역

- Method area
- Heap
- Heap 안의 runtime constant  pool

### **Method Area**

**= Class Area** 

**= Static Area**

![%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%205.png](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%205.png)

- 클래스 정보를 처음 메모리 공간에 올릴 때 **초기화되는 대상을 저장하기 위한 공간**입니다. 올라가게 되는 메서드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드입니다. 자바는 main 메서드로 부터 객체 생성 메소드 호출의 흐름을 이어가기 때문에 **거의 모든 바이트 코드가 올라간다고** 보면 됩니다.

### **Runtime Constant Pool**

Heap 공간에는 **Runtime Constant Pool** 이라는 공간이 존재하는 데 이는 상수 자료형을 저장하여 참조하고 중복을 막기위한 공간입니다.

**올라가는 정보의 종류**

- 멤버변수, 메서드에 대한 정보 (이름, 타입 접근제어자 등등)
- class 인지 interface 인지의 여부 저장, Type 의 속성 , 전체 이름, super class 의 전체이름(interface 이거나 object인 경우 제외)

Method Area 는 클래스를 위한 공간이라면 Heap 영역은 객체를 위한 공간입니다.

### **Heap 영역**

- 객체를 저장하는 가상 메모리 공간입니다. new 연산자로 생성된 객체와 배열을 저장합니다. 물론 Class Area 에 올라온 클래스들만 객체로 생성할 수 있습니다.

![%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%206.png](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%206.png)

### Young Generation

- Eden : 객체들이 최초로 생성되는 공간입니다.
- Survivor 0 / 1 : Eden 에 의해 참조되는 객체들이 저장되는 공간입니다.

### **Old Generation**

- 접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체들이 저장되는 공간입니다.

### **Permanent Generation**

= **Method Area**

- 생성된 객체들의 주소값이 저장된 공간입니다.
- Class Loader 에 의해 로드되는 Class, Method 등에 대한 Meta 데이터가 저장되는 영역이고 JVM에 의해 사용됩니다.
- Reflection을 사용해 동적으로 클래스가 로딩 되는 경우에 사용합니다.

    → 내부적으로 Reflection 을 자주 사용하는 Spring Framework를 사용한다면 이 영역에 대한 고려가 필요합니다.

Java 8부터는 **Permanent 영역대신 Metaspcae 로 호출되는 네이티브 영역에 저장**됩니다.

## **Execution Engine**

- 클래스를 실행시키는 역할 입니다. 클래스 로더에 의해 JVM 내에 로딩된 클래스 파일(바이트 코드)은 실행 엔진에 의해 실행되어 컴퓨터가 이해할 수 있는 기계어로 변환합니다.

**Interpreter**

- 실행 엔진은 자바 바이트 코드를 명령어 단위로 읽어서 해석합니다. 이는 자바의 단점으로 한줄 씩 읽어서 속도가 느립니다.

**JIT(Just - In - Time)**

- **인터프리터의 단점을 보완**하기 위해 도입된 JIT 입니다. 인터프리터로 실행하다가 적절한 시점에 바**이트코드 전체를 컴파일 하여 기계어(네이티브 코드)로 변경 캐시에 저장**합니다. 캐시에 보관된 네이티브 코드를 사용하기 때문에 한 번 컴파일 된 후에는 빠르게 수행할 수 있습니다. 하지만 JIT로 컴파일 하는 과정이 당연히 인터프리팅 하는것보다 느리기 때문에 한번만 실행되는 코드라면 인터프리팅 하는것이 유용합니다.

# GC

[https://www.youtube.com/watch?v=vZRmCbl871I](https://www.youtube.com/watch?v=vZRmCbl871I)

### **가비지(Garbage)의 의미**

- 시스템에서 더 이상 사용하지 않는 메모리

### **가비지 컬렉션(Garbage Collection)**

어떤 데이터를 동적으로 메모리에 할당하여 저장을 한 후 더 이상 필요하지 않을 때, 즉 어떠한 참조변수도 해당 메모리 영역을 가르키지 않을때 메모리를 재사용하기 위해 해당 데이터가 저장된 메모를 탐지하여 해제하는 기법.

가비지를 회수하여 메모리 공간을 늘려 메모리 재사용이 가능.

### **장점**

- 자동적으로 사용하지 않는 메모리를 해제메모리 누수 방지

### **단점**

- 자동적으로 메모리를 해제 한다고 하나 그 시점이 정확하지 않아 실시간 시스템에 적합하지가 않음
- 해제 작업에 비용이 들기 때문에 오버헤드 발생 가능

### **가비지 컬렉션 발생 시기**

- **메모리 영역이 충분하지 않은 상황**에서 Heap 메모리에 동적 할당되면 가비지 컬렉터가 실행하며 사용하지 않은 메모리를 수거합니다.
- 가비지 컬렉터는 가끔식 실행이 되지만 시점을 알기 어려우며 플랫폼마다 다르게 발생합니다.

### **가비지 컬렉터(Garbage Collector)**

- **가비지 컬렉션이 쓰레기를 수집하는 역할**이라면 **가비지 컬렉터는 쓰레기를 수집하는 수집기**라고 보시면 됩니다.
- **동적으로 할당된 메모리가 더이상 사용되지 않을때** 가비지 컬렉터들이 사용하지 않는 영역을 **탐색 → 분리 → 수집**을 합니다.

### Mark 와 Sweep

**Mark**

GC 가 스택의 모든 변수 및 객체를 스캔 하면서 각각 어떤 객체를 참고하고 있는 지 찾는 것

**Sweep**

Mark 되어 있지 않은 객체 틀에서 제거

## 다시 Heap...

![%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%206.png](%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%2070a144a42c024f92aa33693a1e422efb/Untitled%206.png)

### Young Generation

- **Minor GC**가 해당 영역의 객체 관리
- Eden 에서 객체가 가득 차면 첫 번째 GC (minor GC) 가 발생
- Eden 영역에 있는 값들을 Survivor 1 영역에 복사

### Old Gen

- **Major GC**가 해당 영역의 객체 관리
- 대부분 Young 영역보다 크게 할당됨

    → 크기가 큰 만큼 Young 영역보다 GC는 적게 발생

### Permanent Gen

- JVM 은 더이상 인스턴스가 존재할 필요가 없을 때 인스턴스를 완전 소멸시킴

### Garbage Collection 과정

```markdown
[minor GC]
1. 어떠한 새로운 객체가 들어오면 Eden Space에 할당
2. Eden space가 가득차게 되면, 비참조 객체는 삭제되고 참조 객체는 S0 공간으로 이동
3. 첫 번째 survivor space에 있는 객체들의 age가 증가하면, 비참조 객체는 삭제되고 참조 객체는 S1 공간으로 아예 이동. 
	- 주의! S0와 Eden 공간은 Clear
4. 참조되는 객체들은 다시 S0로 이동
	- Eden과 S1 공간은 Clear
5. minor GC 때 2, 3 과정 반복
[major GC]
6. 특정 객체가 age threshold을 넘으면 young generation에서 old로 promotion 시작
7. old Generation clear 후 공간 Compact
```

- 참고자료

    [https://asfirstalways.tistory.com/158](https://asfirstalways.tistory.com/158)

    [https://asfirstalways.tistory.com/159](https://asfirstalways.tistory.com/159)

    [https://johngrib.github.io/wiki/java8-why-permgen-removed/](https://johngrib.github.io/wiki/java8-why-permgen-removed/)

    [https://madplay.github.io/post/java-reflection](https://madplay.github.io/post/java-reflection)

    [https://asfirstalways.tistory.com/159](https://asfirstalways.tistory.com/159)

    [https://gyoogle.dev/blog/computer-language/Java/Garbage Collection.html](https://gyoogle.dev/blog/computer-language/Java/Garbage%20Collection.html)