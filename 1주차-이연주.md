# 1주차 연주

## 자료형

- Primitive

    실제 데이터 값을 저장하는 자료형

    크게 논리형, 문자형, 실수형

    boolean, char, byte(-128-127) , short, int, long, float, double

- Reference Type

    메모리 주소 값을 통해 객체를 참조하는 타입

    **실제 객체** - **힙** 영역에 저장

    **참조 타입 변수** - **스택** 영역에 실제 객체들의 주소를 저장

    객체를 사용할때 참조 변수에 저장된 객체의 주소를 불러와 사용하는 방식

```java
Integer a = (Integer) 500;
Integer b = (Integer) 500;
System.out.println(a==b); //false

Integer a = 127;
Integer b = 127;
System.out.println(a==b); //true
```

`IntegerCache.low` 보다 크고 `IntegerCache.high` 보다 작은 int 리터럴 `i`를 넘긴다면, **Integer.valueOf()** 메소드는 `IntegerCache` 로부터 Integer 객체들을 리턴 **IntegerCache.low** 와 **IntegerCache.high** 의 기본값은 각각 `-128`과 `127`.

즉, **Integer.valueOf()** 메소드는 **-128** 에서 **127** 사이의 int literal을 넘겨줄 때, 새로운 Integer 객체를 생성하고 리턴하는 대신, 내부의 **IntegerCache** 객체에서 Integer 객체를 반환한다

캐시는 static block에 의해 IntegerCache 클래스가 메모리에 로드되는 처음에 초기화된다.

Java는 -128 부터 127 범위의 정수 객체를 캐싱한다. 이 범위의 정수들은 개발할 때 빈번하게 사용되기 때문이다.

Integer 캐시는 범위를 수정할 수 있지만 그외 타입 캐시는 수정 불가능하다.

- Integer과 int 크기 비교

## Primitive type과 Wrapper class

Primitive type : int 

- 산술연산 가능
- null로 초기화 불가능

Wrapper class

- 산술연산 불가능

    → Unboxing으로 가능

- null 값 처리 가능

    → DB에서 특정 컬럼의 자료형이 정수형이지만 null이 들어올 수 있을 때 VO에서 Integer를 사용하여 null인 경우를 처리할 수 있다  

## Boxing과 Unboxing

- Boxing

    Primitive 자료형 → Wrapper 클래스

- Unboxing

    Wrapper 클래스 → Primitive 

## 싱글톤

- 객체를 하나만 생성해야 할 때
- 그리고 그 객체에 어디서든 접근이 가능해야 할 때

```java
public class Star{

	private static Star instance = new Star();

	private Star() {}

  public static Star getInstance() {
      return instance;
  }
}
```

### [싱글톤 패턴 작성 방식](https://webdevtechblog.com/%EC%8B%B1%EA%B8%80%ED%84%B4-%ED%8C%A8%ED%84%B4-singleton-pattern-db75ed29c36)

- eager intialization

     위 코드의 방식

    클래스가 최초로 로딩 될 때 객체가 생성되기때문에 Thread-safe

- Lazy Initialization with synchronized

    동적 바인딩(dynamic binding)(런타임시에 성격이 결정됨)을 통해 인스턴스를 생성

    synchronized 키워드를 이용한 게으른 초기화 방식인데, 메서드에 동기화 블럭을 지정해서 Thread-safe

- Lazy Initialization. Double Checking Locking(DCL, Thread-safe)

    인스턴스가 생성되지 않은 경우에만 동기화 블럭이 실행되게끔 구현하는 방식

- Lazy Initialization. LazyHolder(게으른 홀더, Thread-safe)

    volatile 이나 synchronized 키워드 없이도 동시성 문제를 해결

### **자바와 스프링의 싱글톤 차이**점

**싱글톤 객체의 생명주기가 다르다**

- 자바 싱글톤 객체의 범위는 **클래스 로더**가 기준
- 스프링에서는 **어플리케이션 컨텍스트**가 기준

    Bean을 등록할 때 범위의 default는 Singleton다. 싱글톤 이외 범위는 prototype, request, session이 있다.

## final

- 클래스 앞에 final키워드가 붙으면 '자식을 가질수 없는 최종 클래스'
- 메소드 앞에 final키워드가 붙으면 '더이상 오버라이딩 할 수 없는 최종 메소드'
- 변수 앞에 final은 상수화

주의!! final int[] array로 할당된 그 변수의 수정 (혹은 새로운 값 할당)이 금지된거지,
그 변수가 가리키고 있는 참조안에 있는 값들이 immutable이라는 뜻은 아님

## 상속

- 자식 클래스에서 오버라이딩하는 메서드는 이름이 같아야 한다.
    - 매개변수가 같아야 한다.
    - 리턴 타입이 같아야 한다.
- **접근 제어자**를 부모 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
- **예외**는 부모 클래스의 메서드보다 많이 선언할 수 없다.
- 인스턴스 메서드를 static메서드로 또는 그 반대로 변경할 수 없다.

## 상속 키워드

인터페이스 <- 클래스 implements
인터페이스 <- 인터페이스 extends★

## 추상클래스와 인터페이스

### 추상클래스

- 단일상속
- is-a
- 생성자가질수있음

### 인터페이스

- 다중상속
- has-a
- 생성자가질수없음
- 인터페이스 멤버변수는 **public static final** 고정
- 인터페이스 메서드 **public** 고정
- 상속받은 메서드는 overriding하더라도 public
    - 자바 8 default 메서드 쓸 수 있음
    - 자바 9 private, private static를 쓸 수 있음

## 접근제어자(접근범위 넓은 순으로)

public - protected - default - private
전체 - (다른패키지)자손/상속 - 같은패키지 - 같은클래스

주의!!! 최상위 클래스에만 사용될 수 있는 접근제한자는 public이다

## 다형성+상속

1. 참조변수가 더 상위클래스 >= 
2. 메서드 호출할 때, (동적바인딩)
    - 참조변수의 클래스에 해당 메서드가 있는가
    - 참조변수의 클래스의 부모클래스에 해당 메서드가 있는가
    - new로 생성되는 (오른쪽) 클래스에 해당 메서드가 있는가
    - new로 생성되는 (오른쪽) 클래스까지 하위 클래스 중에 해당 메서드가 있는가

## 동적바인딩

컴파일시 참조변수의 클래스 타입이지만 런타임시 해당 클래스를 찾아간다

### instanceof 연산자

- null instanceof Object
instanceof연산에서 앞에 null이 오면 무조건 false를 반환한다.

## 컬렉션 프레임워크

Collection 인터페이스

- List 인터페이스
    - ArrayList
        - synchronized를 이용한 과도한 동기화는 성능을 떨어뜨릴 수 있고 교착 상태에 빠뜨릴 수 있으며, 예측할 수 없는 동작을 유발
    - CopyOnWriteArrayList
        - 내부의 배열은 절대 변경할 수 없으므로 순회할 때 락이 필요 없어서 속도면에서 매우 빠르다
        - List를 읽기 위해 어딘가에 전달할 때 원본이 아닌 복사본을 만들어서 전달
    - synchronizedList

        동기화로 스레드 세이프

        한번에 하나의 스레드만 접근

- Set 인터페이스
    - Set에 null이 추가된다
- Queue 인터페이스

Map은 컬렉션을 상속하지 않는다

- Map 인터페이스

    **HashMap의 키에 오는 클래스에 hashcode + equals 재정의**

    - HashMap 키에 null이 된다

### 컬렉션에서 오토박싱/언박싱

- 오토 언박싱

    컬렉션에서 값을 읽어서 기본타입에 할당

- 오토 박싱

    컬렉션에다가 기본타입 저장
    **컬렉션에는 무적권 "객체"만 저장가능**!

## Comparable Comparator 인터페이스

메소드 1개밖에 없음
new Priority Queue((a, b) -> {
return a-b;});

## 스트림 종류

- FileInputStream 비문자
- FileReader 문자
- BufferedReader로 개행단위

```java
File file = new File("c:\\example\\File\\umejintan_new.txt");
input = new FileInputStream(file);
int readBuffer = 0;
byte [] buffer = new byte[512];
while((readBuffer = input.read(buffer)) != -1) {
System.out.write(buffer, 0, readBuffer);
}
```

```java
File file = new File("C:\\Users\\world\\Desktop\\javaprogramming\\FileIO\\Sample.txt");
FileReader filereader = new FileReader(file);
//입력 버퍼 생성
BufferedReader bufReader = new BufferedReader(filereader);
String line = "";
while((line = bufReader.readLine()) != null){
System.out.println(line);
}
```

- File.Seperator
운영체제에 상관없이
- 직렬화
객체의 상태값을 일렬로 나열한 것
객체의 상태값을 객체로 복원한 것

### 면접질문

### 클래스에서 사용하는 **변수의 3가지 종류에 대해 설명해주세요.**

- 로컬 변수는 메서드 내에서 선언된 위치부터 소속된 중괄호가 끝나는 지점까지 사용이 가능합니다.
- 인스턴스 변수는 클래스를 통해 생성된 인스턴스 내에서 접근이 가능합니다.
- 클래스 변수는 클래스의 모든 인스턴스에서 공유하는 변수로서 클래스가 메모리에 올라갈 때 static 영역에 생성됩니다.

### **Wrapper Class에 대해 설명하시오.**

- 8개의 기본 타입에 해당하는 데이터를 객체로 포장해주는 클래스
- Wrapper 클래스를 이용할 때 주의할 점은 참조형끼리 연산이 불가능하기 때문에 기본 자료형으로 변환하여 연산해야 한다.

### **StringBuilder와 StringBuffer의 차이점을 설명해주세요.**

- 둘의 차이점은 동기화 처리 여부입니다.
- StringBuilder는 동기화 처리를 하지 않아 StringBuffer보다 속도가 더 빠릅니다. StringBuffer은 속도는 느리지만 멀티 스레드 환경에서 안전하게 사용할 수 있습니다.

### 문제1

```java
class A {
	String go() {
		return "Go!";
	}
}
```

```java
class B extends A {
	//int go() {
	//	return 3;
	//}
	String go() {
		return "3";
	}
}
```

```java
public class Main {
	public static void main(String[] args) {
		A a = new B();
		System.out.println(a.go());
	}
}
```

실행 결과는?

1. 컴파일 에러
2. 런타임 에러
3. Go!
4. 3

### 문제 2

```java
String a = "Joylish";
String b = "Joylis"+ "h";
String c = new String("Joylish");
int x = 10;
```

- a == b 는 무엇일까요?
- a + a == a+b 는 무엇일까요?
- a + x == b+x 는 무엇일까요

## 연산

### 1. BigDecimal

BigInteger, BigDecimal로

[https://sejoung.github.io/2019/03/2019-03-07-Item_60_Avoid_float_and_double_if_exact_answers_are_required/](https://sejoung.github.io/2019/03/2019-03-07-Item_60_Avoid_float_and_double_if_exact_answers_are_required/)

### 2. 오버플로우 방지

![1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%20346ad4e8c21e426eb3b1f3217158400b/Untitled.png](1%E1%84%8C%E1%85%AE%E1%84%8E%E1%85%A1%20%E1%84%8B%E1%85%A7%E1%86%AB%E1%84%8C%E1%85%AE%20346ad4e8c21e426eb3b1f3217158400b/Untitled.png)
