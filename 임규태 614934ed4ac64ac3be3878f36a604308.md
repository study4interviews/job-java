# 임규태

# JVM

- WORA(Write Once, Run Anywhere) ⇒ Java Byte Code(.class) 파일을 JVM 위에서 실행시켜 OS에 종속적이지 않은 실행환경을 만든다.

![%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled.png](%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled.png)

### 1. Class Loader SubSystem

![%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%201.png](%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%201.png)

1. **로딩**
    - 세 가지 클래스 로더들에 의해서 클래스가 로드되며 *위임* 방식으로 작업한다.

        ![%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%202.png](%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%202.png)

        - System ClassLoader ➡ (위임) Extension ClassLoader ➡ (위임) Bootstrap ClassLoader
        - Bootstrap에서 해당 클래스를 못 찾은 경우, (요청 넘김) Extension ClassLoader
        - Extension에서 해당 클래스를 못 찾은 경우, (요청 넘김) System ClassLoader
        - System에서 해당 클래스를 못 찾은 경우, User-defined까지 가지 않음, `Exception`
    - `BootStrap ClassLoader` : jre의 lib 폴더에 있는 rt.jar 파일에서 기본 Java API 라이브러리를 로드. 가장 최우선으로 로드됨 (C 나 C++같은 Native Language로 구현되어 있다)
    - `Extension ClassLoader` : jre의 lib 폴더에 있는 ext 폴더에 있는 모든 확장 코어 클래스파일들을 로드. jdk 확장 디렉토리에서 로드됨
    - `Application ClassLoader` : 사용자가 정의한 클래스들이 로드됨. *classpath* 환경변수에 있는 클래스 파일들이나 *-classpath* or *cp* 명령어 옵션이 있는 파일들도 로드됨.
2. **연결**
    - `검증` : 바이트 코드 검증기가 ByteCode가 적절한지 아닌지에 대한 검증을 실시함. 검증 실패시 오류
    - `준비` : 모든 Static변수의 메모리가 할당됨(default 값으로, 초기화되지 않음)
    - `해석` : Symbolic references(명확하게 정의되지 않은 참조)를 Method Area에 있는 타입으로 Direct references한다.
3. **초기화**
    - 클래스 로딩의 마지막 단계로 모든 Static변수가 초기화되고 Static 블록이 실행

### 2. Runtime Data Area

![%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%203.png](%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%203.png)

- 주로 5가지 영역으로 구분된다.
1. `Method Area` : 모든 클래스 수준( 클래스명, 부모 클래스명, 메소드, 변수 등 )의 데이터가 저장됨. 모든 Thread 공유 자원
2. `Heap Area` : 모든 인스턴스 (클래스의 인스턴스, 배열 등) 가 저장됨. 모든 Thread 공유 자원
3. `Stack Area` : 각 Thread마다 가지는 영역
4. `PC Register` : 실행중인 명령문의 주소, 각 Thread마다 가지는 영역
5. `Native Method Stack` : Native Method 정보를 가짐. 각 Thread마다 생성됨

### 3. Execution Engine

![%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%204.png](%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%204.png)

- Runtime Data Area에서 할당된 Byte Code가 `Execution Engine` 에서 실행되며 바이트 코드를 조각단위별로 실행한다.
1. `인터프리터` : 바이트 코드를 한줄씩 해석하여 실행. 반복되는 코드는 `JIT Compiler` 최적화하여 보완함
2. `JIT Compiler(Just-In-Time)` : 반복되는 코드를 Native Code로 컴파일하여 `인터프리터` 없이 사용 가능하게 함
3. `가비지 컬렉터(Garbage Collector)` : 참조가 없는 인스턴스를 모아 제거함

### 4. Garbage Collection

- Heap 영역에 있는 인스턴스가 Thread의 Stack에서 도달할 수 없는 것들이 GC의 대상이 된다.
- GC가 일어나면 Thread들은 모두 멈춰야 한다(Stop-The-World).
- `Mark And Sweep` 방식 사용
    - `Mark` : GC가 JVM Stack영역을 돌면서 Heap의 어떤 메모리를 참조하는지 확인한다.
    - `Sweep` : `Mark` 되지 않은 인스턴스들을 제거한다.

![%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%205.png](%E1%84%8B%E1%85%B5%E1%86%B7%E1%84%80%E1%85%B2%E1%84%90%E1%85%A2%20614934ed4ac64ac3be3878f36a604308/Untitled%205.png)

- Heap영역은 `Young` , `Old` , `Perm` 세 영역으로 나뉜다.
- `Young` 영역은 다시 `Eden` 영역과 `두 개의 Survivor` 영역으로 나뉜다.
1. 객체가 생성되면 `Eden` 에 생성된다.
2. `Eden` 에 데이터가 어느정도 쌓이면 삭제되거나 `Survivor` 로 옮겨진다.
3. `Survivor` 에 데이터가 어느정도 쌓이면 다시 `Eden` 에 있는 객체와 `현재 Survivor` 에 있는 객체가 `비어있는 Survivor` 으로 이동한다.
4. 더이상 `Young` 에 공간이 남지 않으면 `Survivor` 에서 오래 살아남은 객체들은 `Old` 로 이동하게 된다.
- `Young` 에서 일어나는 GC를 **Minor GC**, `Old` 에서 일어나는 GC를 **Major GC**, `Heap 전체` 에서 일어나는 GC를 **Full GC** 라고 한다.
    - **Minor GC** : JVM이 새로운 객체를 생성하기 위한 메모리를 확보하지 못하면 무조건 발생.
    Old 의 객체가 Young 객체를 참조하고 있을 경우 Mark.
    Young 의 객체가 Old 객체를 참조하고 있을 경우 Mark하지 않음.

[Dongho Sim's dev story|Garbage Collection 기본 개념](https://dhsim86.github.io/java/2018/02/04/what_is_garbage_collection-post.html)

[JVM 메모리 구조 및 아키텍쳐(클래스 로더, 실행엔진 등)](https://sas-study.tistory.com/262?category=774876)

[[Java] ClassLoader, Class Loading Process](https://velog.io/@leede418/Java-ClassLoader-Class-Loading-Process)